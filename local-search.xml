<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>守望先锋，再见。</title>
    <link href="/2022/10/05/overwatch-return/"/>
    <url>/2022/10/05/overwatch-return/</url>
    
    <content type="html"><![CDATA[<p>如果要选一款我游戏中的白月光，毫无意外，就是守望先锋了。</p><span id="more"></span><p>和暴雪的不解之缘最开始出现在五年级的那个圣诞节晚上，我的父亲用他14英寸的老戴尔带着我打了我人生中第一把星际争霸。</p><p>虫族，速本爆狗一波流。</p><p>我难以想象在1998年就有人做出这样一款游戏性和世界观都无可挑剔的作品。靠着一本牛津英汉词典。我硬生生的打通了星际1的剧情模式。最后一幕CG放完的那个下午，我的人生目标就确立了：  </p><p>去暴雪，做出很COOL的游戏。</p><p>上了初中的我接触到了战网，续上了科普鲁星区的故事；开始了艾泽拉斯的冒险；结识了时空枢纽的英雄；交上了符文之地的朋友。耳闻暴雪在做一款名为TITAN的旷世MMORPG巨作，虽然其最后难产变成了一款射击游戏，但我也翘首以盼。</p><p>328元。那时候我没有银行卡没有支付宝，一张点卡30块，我买了11张。</p><p>拿着那一沓卡片走回家，我觉得我是这个世界上最幸福的小孩。</p><p>2016年，我14岁。近未来的故事背景，各具特色的角色设计，还有一堆待发掘的彩蛋和对英雄的致意。机械忍者，时空回溯，能变成重机枪的机器人，靠着音乐战斗的DJ，穿着合金重铠拿着喷射巨锤的圣骑士，掌握起死回生之力的战场女武神。每个中午，我都会骑上我的小单车，风驰电掣地飞回家中，用U盘里准备好的程序干开那台WINDOWS7的密码，徜徉在那个世界里。</p><p>但是，我长大了，它没有。</p><p>不知什么时候，暴雪死了。先是商业化赛事失败，然后是风暴英雄停更，然后是星际，然后是“你们没有手机吗？”，然后是原版没啥区别的魔兽Ⅲ重置和父马可亲的汉化······我都记不清先后了，我也从一个只玩暴雪游戏的暴白变成了恨不得暴雪早点死的暴黑。</p><p>你问守望？守望一直是那样，除了一点无足轻重的平衡性改动外，开发组就像死了一样销声匿迹。</p><p>都这样了，体面点吧。</p><p>我本来不想给暴雪这个机会了。</p><p>但我说不上来。</p><p>守望先锋关服了。</p><p>我的青春结束了。</p><p>或者说，它早就结束了，只是需要一个体面的葬礼。</p><p>至于守望二，我已经不是14岁了，暴雪也不是那个暴雪了。</p><p>但是我愿意给他这个机会。</p><p>这个世界需要英雄。</p>]]></content>
    
    
    
    <tags>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重走大一路：STM32的入门笔记(1)</title>
    <link href="/2022/10/04/STM32/"/>
    <url>/2022/10/04/STM32/</url>
    
    <content type="html"><![CDATA[<p>STM32作为现今最常用的机器人主控MPU非常重要，很有必要好好学习。第一章笔记，将给出它的概述。</p><span id="more"></span><p>我将解答部分我之前不太明白的部分问题和术语，希望对看这篇文章的你也有些帮助。</p><h1 id="1-初识STM32"><a href="#1-初识STM32" class="headerlink" title="1.初识STM32"></a>1.初识STM32</h1><blockquote><p>STM32系列是专为要求高性能、低成本、低功耗的嵌入式应用设计的ARM Cortex®-M0，M0+，M3, M4和M7内核 （ST’s product portfolio contains a comprehensive range of microcontrollers, from robust, low-cost 8-bit MCUs up to 32-bit ARM-based Cortex®-M0 and M0+, Cortex®-M3,Cortex®-M4 Flash microcontrollers with a great choice of peripherals. ST has also extended this range to include an ultra-low-power MCU platform)。<br>按内核架构分为不同产品：主流产品（STM32F0、STM32F1、STM32F3）、超低功耗产品（STM32L0、STM32L1、STM32L4、STM32L4+）、高性能产品（STM32F2、STM32F4、STM32F7、STM32H7<br>（来自百度百科）</p></blockquote><p>用人话讲，STM32是一款32位的单片机MCU(Micro Control Unit)，适用于许多开发环境。它就是整个机器人的大脑，负责主控。它通过控制引脚上的高低电平来控制外部执行器。<br>它的内核基于<strong>ARM® Cortex®-M</strong>（一种ARM公司的处理器架构设计）。<a href="https://blog.csdn.net/erinblog/article/details/78156032">衍生阅读</a></p><p>想使用STM32首先我们要会<a href="https://www.dotcpp.com/"><strong>C语言</strong></a>。还要有基本的<strong>模电数电知识</strong>。若有<strong>计算机组成原理</strong>的基础更好，但不会也不影响基本的使用。</p><h1 id="2-命名规则"><a href="#2-命名规则" class="headerlink" title="2.命名规则"></a>2.命名规则</h1><p><img src="/img/stmxiangjie.png"></p><h1 id="3-术语解释"><a href="#3-术语解释" class="headerlink" title="3.术语解释"></a>3.术语解释</h1><h2 id="开发板"><a href="#开发板" class="headerlink" title="开发板"></a>开发板</h2><p>开发板是一些企业或组织为了方便不懂硬件设计的群体设计的含主控芯片的电路板，上面有各种元器件和接口，方便这些群体直接通过开发板进行对主控的编程和对执行器的控制。</p><h2 id="上位机和下位机"><a href="#上位机和下位机" class="headerlink" title="上位机和下位机"></a>上位机和下位机</h2><blockquote><p>上位机是指可以直接发出操控命令的计算机，一般是PC&#x2F;host computer&#x2F;master computer&#x2F;upper computer,屏幕上显示各种信号变化（液压，水位，温度等）。下位机是直接控制设备获取设备状况的计算机，一般是PLC&#x2F;单片机single chip microcomputer&#x2F;slave computer&#x2F;lower computer之类的。上位机发出的命令首先给下位机，下位机再根据此命令解释成相应时序信号直接控制相应设备。下位机不时读取设备状态数据（一般为模拟量），转换成数字信号反馈给上位机。简言之如此，实际情况千差万别，但万变不离其宗：上下位机都需要编程，都有专门的开发系统。<br>在概念上，控制者和提供服务者是上位机，被控制者和被服务者是下位机，也可以理解为主机和从机的关系，但上位机和下位机是可以转换的。<br><a href="https://zhuanlan.zhihu.com/p/77587097#:~:text=%E4%B8%8A%E4%BD%8D%E6%9C%BA%E6%98%AF%E6%8C%87%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%8F%91%E5%87%BA%E6%93%8D%E6%8E%A7%E5%91%BD%E4%BB%A4%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%8C%E4%B8%80%E8%88%AC%E6%98%AFPC%2Fhost%20computer%2Fmaster%20computer%2Fupper%20computer%2C%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%90%84%E7%A7%8D%E4%BF%A1%E5%8F%B7%E5%8F%98%E5%8C%96%EF%BC%88%E6%B6%B2%E5%8E%8B%EF%BC%8C%E6%B0%B4%E4%BD%8D%EF%BC%8C%E6%B8%A9%E5%BA%A6%E7%AD%89%EF%BC%89%E3%80%82,%E4%B8%8B%E4%BD%8D%E6%9C%BA%E6%98%AF%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E8%AE%BE%E5%A4%87%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E7%8A%B6%E5%86%B5%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%8C%E4%B8%80%E8%88%AC%E6%98%AFPLC%2F%E5%8D%95%E7%89%87%E6%9C%BAsingle%20chip%20microcomputer%2Fslave%20computer%2Flower%20computer%E4%B9%8B%E7%B1%BB%E7%9A%84%E3%80%82">引用来源</a></p></blockquote><h2 id="HAL库，标准库和直接配置寄存器"><a href="#HAL库，标准库和直接配置寄存器" class="headerlink" title="HAL库，标准库和直接配置寄存器"></a>HAL库，标准库和直接配置寄存器</h2><p>STM32的开发商ST（意法半导体）官方有封装好的<a href="https://cloud.tencent.com/developer/article/1861948"><strong>HAL库</strong></a>（ST官方推荐的库），<strong>标准固件库</strong>（旧版本库，现已不再更新）可用于STM32的编程，同样你也可以使用<strong>寄存器编程</strong>（较繁琐）。现在大部分情况都使用HAL库。</p><blockquote><p>1、直接配置寄存器<br>不少先学了51的朋友可能会知道，会有一小部分人或是教程是通过汇编语言直接操作寄存器实现功能的，这种方法到了STM32就变得不太容易行得通了，因为STM32的寄存器数量是51单片机的十数倍，如此多的寄存器根本无法全部记忆，开发时需要经常的翻查芯片的数据手册，此时直接操作寄存器就变得非常的费力了。但还是会有很小一部分人，喜欢去直接操作寄存器，因为这样更接近原理，知其然也知其所以然。<br>2、标准库<br>上面也提到了，STM32有非常多的寄存器，而导致了开发困难，所以为此ST公司就为每款芯片都编写了一份库文件，也就是工程文件里stm32F1xx…之类的。在这些 .c .h文件中，包括一些常用量的宏定义，把一些外设也通过结构体变量封装起来，如GPIO口时钟等。所以我们只需要配置结构体变量成员就可以修改外设的配置寄存器，从而选择不同的功能。也是目前最多人使用的方式，也是学习STM32接触最多的一种开发方式，我也就不多阐述了。<br>3、HAL库<br>HAL库是ST公司目前主力推的开发方式，全称就是Hardware Abstraction Layer（抽象印象层）。库如其名，很抽象，一眼看上去不太容易知道他的作用是什么。<br>它的出现比标准库要晚，但其实和标准库一样，都是为了节省程序开发的时期，而且HAL库尤其的有效，如果说标准库把实现功能需要配置的寄存器集成了，那么HAL库的一些函数甚至可以做到某些特定功能的集成。也就是说，同样的功能，标准库可能要用几句话，HAL库只需用一句话就够了。<br>并且HAL库也很好的解决了程序移植的问题，不同型号的stm32芯片它的标准库是不一样的，例如在F4上开发的程序移植到F3上是不能通用的，而使用HAL库，只要使用的是相通的外设，程序基本可以完全复制粘贴，注意是相通外设，意思也就是不能无中生有，例如F7比F3要多几个定时器，不能明明没有这个定时器却非要配置，但其实这种情况不多，绝大多数都可以直接复制粘贴。是而且使用ST公司研发的STMcube软件，可以通过图形化的配置功能，直接生成整个使用HAL库的工程文件，可以说是方便至极，但是方便的同时也造成了它执行效率的低下，在各种论坛帖子真的是被吐槽的数不胜数。</p></blockquote><p><a href="https://cloud.tencent.com/developer/article/1861948">引用来源及扩展阅读</a></p><h2 id="8位，32位和64位"><a href="#8位，32位和64位" class="headerlink" title="8位，32位和64位"></a>8位，32位和64位</h2><p>32位和64位操作系统是指，CPU一次处理数据的能力是32位还是64位。  所谓32位，就是CPU一次只能处理32位，也就是4个字节的数据；而64位，CPU一次就能处理64位，即8个字节的数据。<br>51单片机大部分为8位，而STM32的位数为32位。</p><h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><blockquote><p>Jlink支持所有ARM芯片的仿真调试，而STlink仅仅支持ST公司的相关芯片。<br><a href="https://blog.csdn.net/ReCclay/article/details/79156325">引用来源及扩展阅读</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>audio | 航站楼第一次的audio</title>
    <link href="/2022/10/02/first_audio/"/>
    <url>/2022/10/02/first_audio/</url>
    
    <content type="html"><![CDATA[<p>做技术的人的自我修养应该是怎么样的？我觉得大家心里都有自己的答案。</p><span id="more"></span><p>以我之鄙见，最重要的一点应该是热爱技术，其次应该是持续而稳定的热情输出，最后则是一点灵感和机遇。</p>]]></content>
    
    
    
    <tags>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
