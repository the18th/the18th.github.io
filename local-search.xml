<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>嵌入式系统原理课程串讲复习</title>
    <link href="/2023/04/14/embedded_review/"/>
    <url>/2023/04/14/embedded_review/</url>
    
    <content type="html"><![CDATA[<p>本文旨在记录HIT嵌入式系统原理课程相关资料  </p><span id="more"></span><p>授课老师：吕为工</p><h2 id="第1章-嵌入式系统基础"><a href="#第1章-嵌入式系统基础" class="headerlink" title="第1章 嵌入式系统基础"></a>第1章 嵌入式系统基础</h2><h3 id="嵌入式系统的一般定义"><a href="#嵌入式系统的一般定义" class="headerlink" title="嵌入式系统的一般定义"></a>嵌入式系统的一般定义</h3><p>是指以应用为中心、以计算机技术为基础、软件硬件可裁剪、适应应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。</p><h3 id="嵌入式系统的组成、嵌入式系统的特点"><a href="#嵌入式系统的组成、嵌入式系统的特点" class="headerlink" title="嵌入式系统的组成、嵌入式系统的特点"></a>嵌入式系统的组成、嵌入式系统的特点</h3><p>组成：就像一般的计算机系统包括软件和硬件一样，嵌入式系统是由<strong>嵌入式硬件和嵌入式软件</strong>组成。<br>特点：<br>1.适应不同的应用场合，个性化很强，软件一般要针对硬件进行移植，追求的是<strong>专用而不是通用</strong>，这也是嵌入式系统<strong>开发周期较长</strong>的根本原因<br>2.一般工作在<strong>资源有限的环境</strong>中，对<strong>功耗、体积等都有着特定的要求</strong>，其<strong>功能的设计及实现一般不会太复杂</strong>。<br>3.<strong>应用场合多种多样，功能纷繁复杂</strong>，无法按照某一标准定制。<br>4.通常有各自<strong>专门的开发工具和环境</strong>。<br>5.应用软件很多时候会和操作系统结合在一起，对<strong>代码质量和效率要求很高</strong>。<br>6.使用嵌入式操作系统，而嵌入式操作系统通常要求内核小、可裁剪、多任务，一些应用场合还对可靠性实时性有着极高的要求</p><h3 id="嵌入式系统与台式计算机硬件平台比较"><a href="#嵌入式系统与台式计算机硬件平台比较" class="headerlink" title="嵌入式系统与台式计算机硬件平台比较"></a>嵌入式系统与台式计算机硬件平台比较</h3><table><thead><tr><th align="center">名称</th><th align="center">嵌入式系统</th><th align="center">台式计算机</th></tr></thead><tbody><tr><td align="center">CPU：</td><td align="center">ARM等嵌入式处理器</td><td align="center">Intel,AMD 的X86处理器</td></tr><tr><td align="center">内存：</td><td align="center">SDRAM芯片</td><td align="center">内存条</td></tr><tr><td align="center">存储设备：</td><td align="center">FLASH芯片</td><td align="center">硬盘或固态</td></tr><tr><td align="center">输入设备：</td><td align="center">按键，触摸屏</td><td align="center">鼠标键盘</td></tr><tr><td align="center">输出设备：</td><td align="center">LCD</td><td align="center">显示器</td></tr><tr><td align="center">声音设备：</td><td align="center">音频芯片</td><td align="center">声卡</td></tr><tr><td align="center">接口：</td><td align="center">MAX3232等芯片</td><td align="center">主板集成</td></tr><tr><td align="center">其他设备：</td><td align="center">USB及网络等芯片</td><td align="center">主板集成或外接卡</td></tr></tbody></table><h3 id="嵌入式系统与台式计算机软件平台比较"><a href="#嵌入式系统与台式计算机软件平台比较" class="headerlink" title="嵌入式系统与台式计算机软件平台比较"></a>嵌入式系统与台式计算机软件平台比较</h3><table><thead><tr><th align="center">名称</th><th align="center">嵌入式系统</th><th align="center">台式计算机</th></tr></thead><tbody><tr><td align="center">引导代码</td><td align="center">Bootloader引导，针对电路移植</td><td align="center">主板BIOS引导</td></tr><tr><td align="center">操作系统</td><td align="center">Linux,WINCE,Vxworks等，需要移植</td><td align="center">一般为windows不需移植</td></tr><tr><td align="center">驱动程序</td><td align="center">需针对电路开发或移植</td><td align="center">操作系统含有大部分驱动程序</td></tr><tr><td align="center">协议栈</td><td align="center">需要移植</td><td align="center">操作系统或第三方提供</td></tr><tr><td align="center">开发环境</td><td align="center">借助主机交叉编译</td><td align="center">本机即可开发调试</td></tr><tr><td align="center">仿真器</td><td align="center">需要</td><td align="center">不需要</td></tr></tbody></table><h3 id="嵌入式系统与单片机硬件平台比较"><a href="#嵌入式系统与单片机硬件平台比较" class="headerlink" title="嵌入式系统与单片机硬件平台比较"></a>嵌入式系统与单片机硬件平台比较</h3><table><thead><tr><th align="center">名称</th><th align="center">嵌入式系统</th><th align="center">单片机</th></tr></thead><tbody><tr><td align="center">硬件平台</td><td align="center">厂家提供通用硬件平台</td><td align="center">自己设计制作</td></tr><tr><td align="center">硬件设计</td><td align="center">在基础上裁剪和扩展</td><td align="center">重新设计</td></tr><tr><td align="center">CPU</td><td align="center">一般为32位</td><td align="center">多为8和16位</td></tr><tr><td align="center">MMU</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">功能</td><td align="center">能够实现复杂功能</td><td align="center">难以实现复杂功能</td></tr><tr><td align="center">开发人员</td><td align="center">主要为计算机专业人员</td><td align="center">硬件设计人员</td></tr><tr><td align="center">仿真器</td><td align="center">初始化需要，后续不需要</td><td align="center">全程使用</td></tr><tr><td align="center">仿真头</td><td align="center">不需要</td><td align="center">需要</td></tr></tbody></table><h3 id="嵌入式系统与单片机软件平台比较"><a href="#嵌入式系统与单片机软件平台比较" class="headerlink" title="嵌入式系统与单片机软件平台比较"></a>嵌入式系统与单片机软件平台比较</h3><table><thead><tr><th align="center">名称</th><th align="center">嵌入式系统</th><th align="center">单片机</th></tr></thead><tbody><tr><td align="center">开发平台</td><td align="center">主机对应操作系统</td><td align="center">主机上的仿真软件</td></tr><tr><td align="center">功能</td><td align="center">相对复杂</td><td align="center">相对简单</td></tr><tr><td align="center">运行环境</td><td align="center">嵌入式操作系统</td><td align="center">直接运行在硬件上</td></tr><tr><td align="center">编程语言</td><td align="center">C，JAVA和框架</td><td align="center">C，汇编</td></tr><tr><td align="center">协议支持</td><td align="center">嵌入式操作系统提供，如USB协议和网络协议，移植后使用</td><td align="center">自己实现</td></tr><tr><td align="center">驱动程序</td><td align="center">操作系统提供大部分驱动</td><td align="center">自己实现</td></tr><tr><td align="center">调试</td><td align="center">交叉编译</td><td align="center">专门的仿真软件在线调试</td></tr></tbody></table><h3 id="嵌入式处理器与X86处理器比较"><a href="#嵌入式处理器与X86处理器比较" class="headerlink" title="嵌入式处理器与X86处理器比较"></a>嵌入式处理器与X86处理器比较</h3><table><thead><tr><th align="center">名称</th><th align="center">嵌入式处理器</th><th align="center">X86</th></tr></thead><tbody><tr><td align="center">应用</td><td align="center">特定应用</td><td align="center">家用PC&#x2F;笔记本&#x2F;服务器</td></tr><tr><td align="center">组成</td><td align="center">ALU、MMU、片内Cache、集成网卡、USB等控制器</td><td align="center">ALU、MMU、片内Cache、片内资源有限</td></tr><tr><td align="center">指令系统</td><td align="center">RISC</td><td align="center">CISC</td></tr><tr><td align="center">I&#x2F;O寻址方式</td><td align="center">统一编址</td><td align="center">独立编址</td></tr><tr><td align="center">系统存储</td><td align="center">Flash，启动后全部加载</td><td align="center">硬盘，需要时调入内存</td></tr><tr><td align="center">软件</td><td align="center">面向特定需求，小，精简</td><td align="center">多样复杂全面</td></tr><tr><td align="center">产品使用</td><td align="center">嵌入设备中自动完成</td><td align="center">通过人机交互实现</td></tr><tr><td align="center">关联</td><td align="center">X86常作为嵌入式系统的开发主机</td><td align="center"></td></tr></tbody></table><h3 id="“完整的有交互能力的嵌入式操作系统”与“与应用程序一体化的嵌入式操作系统”"><a href="#“完整的有交互能力的嵌入式操作系统”与“与应用程序一体化的嵌入式操作系统”" class="headerlink" title="“完整的有交互能力的嵌入式操作系统”与“与应用程序一体化的嵌入式操作系统”"></a>“完整的有交互能力的嵌入式操作系统”与“与应用程序一体化的嵌入式操作系统”</h3><p>“完整的有交互能力的嵌入式操作系统”，这种嵌入式操作系统有2个不可或缺的特性：<br>1.要单独安装独立运行<br>2.提供了用户接口</p><p>“与应用程序一体化的嵌入式操作系统”，相对比较简单，如uC&#x2F;OS和QNX等，特点如下：<br>1.不需要单独安装独立运行<br>2.不存在提供交互能力的用户界面(Shell)<br>3.操作系统和应用程序一起形成最终可执行程序，两位一体<br>4.和单片机系统一样通过仿真器及配套软件进行开发调试</p><h3 id="硬实时及软实时操作系统与嵌入式系统的实时性"><a href="#硬实时及软实时操作系统与嵌入式系统的实时性" class="headerlink" title="硬实时及软实时操作系统与嵌入式系统的实时性"></a>硬实时及软实时操作系统与嵌入式系统的实时性</h3><p>硬实时系统：必须对事件做出及时的反应，绝对不能错过事件处理的时限，比如说航天飞机的控制系统<br>软实时系统：在系统负荷较重的时候，允许发生错过时限的情况而且不会造成太大的危害，如液晶屏刷新允许有短暂的延迟</p><p>在嵌入式系统中，实时性的实现依赖于嵌入式操作系统。<br>通常所有的操作系统都可以看作是支持软实时的，实时操作系统和非实时操作系统的区别在于能否支持硬实时系统。<br>具体到操作系统的实现上，<br><strong>非实时操作系统采用基于优先级的调度算法，着重于提供高速响应和大吞吐量</strong><br><strong>实时操作系统使用的是调度方式简单，反应速度快的实时调度算法</strong>，首要任务是调度一切可利用的资源完成实时控制任务</p><h3 id="嵌入式Linux主要特性"><a href="#嵌入式Linux主要特性" class="headerlink" title="嵌入式Linux主要特性"></a>嵌入式Linux主要特性</h3><p>1.完全免费，可以任意修改代码，兼容POSIX1.0标准，可以方便地获得第三方软硬件厂商的支持，驱动程序及其它资源丰富。</p><p>2.有大量的且不断增加的开发工具，这些工具为嵌入式系统的开发提供了良好的开发环境。</p><p>3.有完善的网络支持，适应物联网时代。</p><p>4.可以运行在多种硬件平台上，易于定制裁剪，支持包括x86在内 的几乎所有CPU芯片，可以运行在掌上电脑、机顶盒或游戏机上。</p><p>5.内核小、功能强、稳定健壮、效率高、多任务，作为嵌入式开发的基础平台，还可拓展，安卓就是Linux的拓展。</p><p>6.包含嵌入式浏览器、邮件程序、MP3播放器、MPEG播放器和记事本等丰富的应用程序。</p><h3 id="单片机的开发模式"><a href="#单片机的开发模式" class="headerlink" title="单片机的开发模式"></a>单片机的开发模式</h3><p><strong>主机+仿真器+仿真头+自制硬件</strong></p><p>要先进行硬件系统开发设计，自己制作硬件，<br>而后在主机(PC)上编写C语言或者汇编语言程序，为单片机系统进行软件的开发调试。<br>如果硬件平台设计发生错误，则需要重新开始这个过程。</p><p>单片机系统的软件通常都比较简单，一般由单片机硬件的设计者自己编写。<br>软件开发环境由主机上的仿真软件提供。<br>调试程序时要下载到自制的目标板上的内存，仿真运行。<br>调试好的程序最终要经过烧写固化。</p><p>单片机系统开发的设计难点主要在于硬件平台可能要经过不止一次的设计和实现。<br>有经验的设计者可以减少这个次数，这也是单片机系统设计更加看重经验的原因。<br>硬件的每次实现都需要一定周期，进行制版、采购芯片、焊接和调试。</p><h3 id="嵌入式系统的开发模式"><a href="#嵌入式系统的开发模式" class="headerlink" title="嵌入式系统的开发模式"></a>嵌入式系统的开发模式</h3><p><strong>主机+仿真器+硬件平台</strong>或<strong>主机通过网络通信连接至硬件平台</strong></p><p><strong>完整的嵌入式操作系统</strong>：<br>初始化时一般需要通过仿真器向硬件平台下载嵌入式操作系统的启动加载程序Bootloader<br>在通过Bootloader安装了嵌入式操作系统之后，就不再需要仿真器了<br>只需要利用网络通信(有时也可以利用USB或串口)，下载或通过网络文件系统在目标机上运行程序<br>注：一些新的嵌入式硬件平台不再提供仿真器，而是使用SD卡或USB接口</p><p><strong>与应用程序一体化的操作系统</strong>：<br>开发时使用的是仿真器提供的开发环境<br>这时在整个开发过程中仿真器不可或缺<br>这种方式除了自制硬件平台被通用硬件平台代替外，与单片机系统开发类似</p><p>嵌入式系统开发者的主要任务是在主机上编写基于操作系统的程序，然后通过交叉编译的方式，在嵌入式操作系统环境下调试和运行</p><h3 id="个人移动设备的开发模式"><a href="#个人移动设备的开发模式" class="headerlink" title="个人移动设备的开发模式"></a>个人移动设备的开发模式</h3><p>PMD有单独的操作系统平台，使用与一般嵌入式系统类似的操作系统环境(Linux、类UNIX)<br>PMD的开发模式同样为主机-目标机模式<br>PMD并不象PC一样作为开发环境被使用，它仅是一个应用平台而不是开发平台</p><h2 id="第2章-嵌入式系统硬件平台"><a href="#第2章-嵌入式系统硬件平台" class="headerlink" title="第2章 嵌入式系统硬件平台"></a>第2章 嵌入式系统硬件平台</h2><h3 id="台式机计算机与嵌入式系统硬件平台整体构架"><a href="#台式机计算机与嵌入式系统硬件平台整体构架" class="headerlink" title="台式机计算机与嵌入式系统硬件平台整体构架"></a>台式机计算机与嵌入式系统硬件平台整体构架</h3><p><strong>台式计算机硬件平台整体构架</strong><br>其中逻辑部件包括处理器，存储器，多个输入输出接口和输入输出设备。<br>处理器和存储器直接挂在总线上，I&#x2F;O设备通过I&#x2F;O接口接入总线。<br>各司其职，基本没有功能上的交叉。<br>![[Pasted image 20230412204635.png]]</p><p><strong>嵌入式系统硬件平台整体构架</strong><br>嵌入式处理器内部带有存储器、NandFlash及LCD等I&#x2F;O接口，可以直接连接这类外设。<br>一些接口甚至连同外设一起被集成到芯片内部，如看门狗(watchdog)，实时时钟(RTC)等。</p><p>![[Pasted image 20230412205005.png]]<br>嵌入式处理器内部有了独立的嵌入式处理器内核，有了一些被称为“控制器”的I&#x2F;O接口，<br>在处理器内部，这些部件通过内部总线连接起来，就象计算机系统一样，这正是片上系统SOC含义所在。<br>由于其中每个部件都是一个独立的IP核，也清楚地说明了SOC是基于IP核技术的。<br>由于嵌入式处理器内部提供了常用的I&#x2F;O接口，很多外部I&#x2F;O设备就可以直接与处理器相连了。<br>这样就形成了“处理器+外设”的嵌入式系统的硬件结构。<br>一方面，这种方式简化了系统的构建，降低硬件设计工作量。<br>另一方面，这种结构伸缩性强，正好可以适应嵌入式系统领域应用的多样性。</p><h3 id="一体式主机板与核心式主机板"><a href="#一体式主机板与核心式主机板" class="headerlink" title="一体式主机板与核心式主机板"></a>一体式主机板与核心式主机板</h3><p><strong>一体式主机板</strong>类型会裁剪掉实际应用中不需要使用的多余功能，形成一个整体，嵌入到设备中使用。<br>这种类型的嵌入式主机板有固定的功能和应用领域，更具专用性，一般不需要再改变。<br>适合在有一定批量和通用性的嵌入式产品中使用，如PMD主机板就是这种类型的代表。</p><p><strong>核心式主机板</strong>只包含核心硬件，相当于基于嵌入式处理器的最小系统，使用时通过外围板扩展功能。<br>实际嵌入到设备时，在核心板不变的请况下，通过搭配不同外围板实现嵌入式系统的不同应用需求。<br>核心式主机板适用于需要二次开发的场合，与主机板配套的外围板可以由厂家提供，也可自行开发。<br>核心式主机板上除了包含嵌入式处理器外，一般还配有内存、电子盘、常用设备和总线接口。</p><h3 id="嵌入式系统内部接口与外部接口的编程模式"><a href="#嵌入式系统内部接口与外部接口的编程模式" class="headerlink" title="嵌入式系统内部接口与外部接口的编程模式"></a>嵌入式系统内部接口与外部接口的编程模式</h3><p><strong>片内接口</strong><br>片内接口的编程通过操作嵌入式处理器内部一组特殊寄存器的完成，通常被称为特殊功能寄存器SFR。<br>片内接口的使用按照嵌入式处理器规定好的方式进行，其使用可参见嵌入式处理器的数据手册。</p><p><strong>片外接口</strong><br>外部接口则与外部总线相连，通过端口进行操作。<br>片外接口使用方式按照外部接口采用的接口芯片或电路进行，<br>使用时参照接口芯片的数据手册进行。</p><p>![[Pasted image 20230412205830.png]]</p><h3 id="了解S5PV210处理器的主要特性"><a href="#了解S5PV210处理器的主要特性" class="headerlink" title="了解S5PV210处理器的主要特性"></a>了解S5PV210处理器的主要特性</h3><p>32位RISC，使用Cortex-A8 CPU 指令集，支持MMU，指令及数据cache各32KB，512KB二级Cache</p><p>芯片内置PLL，核心电压1.1V时，可运行800MHz，1.2V时，可以运行1GHz<br>内置SDRAM存储器控制器</p><p>LCD 控制器，支持4K色STN和256K色TFT，带有一个LCD专用DMA<br>24 通道 DMA 控制</p><p>四个UART，64字节收发缓冲区</p><p>三个多主 IIC 总线，三个 IIS 总线控制器，SD&#x2F;MMC卡支持</p><p>1个USB2.0 主机，1个USB2.0 OTG</p><p>4 个 PWM 定时器、看门狗定时器，带日历功能的实时时钟</p><p>237个通用IO，14x8矩阵键盘</p><p>93个中断源，6种电源控制模式</p><p>10通道12位ADC和触摸屏接口</p><h3 id="与存储芯片的连接图"><a href="#与存储芯片的连接图" class="headerlink" title="与存储芯片的连接图"></a>与存储芯片的连接图</h3><p>![[Pasted image 20230412220529.png]]</p><h3 id="Flash与EEPROM比较"><a href="#Flash与EEPROM比较" class="headerlink" title="Flash与EEPROM比较"></a>Flash与EEPROM比较</h3><p>Flash和EEPROM都是常用的非易失性存储技术，但Flash的容量远远超过EEPROM，二者的最主要的区别还是在读写特性上。<br>Flash在写入之前，必须要经过擦除(erase)操作，而且擦除只能以块(block)为单位，整块擦除，即使要修改一个字节的数据，也需要擦除整个块的内容；而EEPROM是可以逐字节修改的。</p><h3 id="NandFlash与NorFlash比较"><a href="#NandFlash与NorFlash比较" class="headerlink" title="NandFlash与NorFlash比较"></a>NandFlash与NorFlash比较</h3><table><thead><tr><th align="center">NandFlash</th><th align="center">NorFlash</th></tr></thead><tbody><tr><td align="center">擦除时数据变为0xFF，写入时只能由1变0</td><td align="center">擦除时数据变为0x00，写入时只能由0变1</td></tr><tr><td align="center">读速度不如Nor flash，而擦、写速度高，容量大，价格低，有取代磁盘的趋势</td><td align="center">读速度高，而擦、写速度低，容量小，价格高</td></tr><tr><td align="center">使用地址和数据引脚构成通用的I&#x2F;O口，通过多次寻址存取数据，其读和写操作以512(或者2K)字节的页(page)为单位</td><td align="center">接口时序与SRAM一样，其地址、数据及读写控制引脚能与CPU的三总线直接连接，就可以很容易地存取其内部的每一个字节</td></tr><tr><td align="center">有单独时序，不可在其上直接运行代码</td><td align="center">可在其上直接运行代码，使用简单</td></tr><tr><td align="center">块的最大擦写次数是一百万次甚至千万次</td><td align="center">而Nor的擦写次数是十万次数量级</td></tr><tr><td align="center">发生位交换错误的次数多，需要使用ECC校验算法 ，需要初始化扫描，标记坏块</td><td align="center">位交换发生次数远远少于NandFlash</td></tr></tbody></table><h3 id="NandFlash的控制引脚信号"><a href="#NandFlash的控制引脚信号" class="headerlink" title="NandFlash的控制引脚信号"></a>NandFlash的控制引脚信号</h3><p>命令锁存引脚CLE<br>芯片写引脚nWE<br>地址锁存引脚ALE<br>芯片读引脚nRE<br>芯片使能引脚nCE<br>就绪&#x2F;忙引脚R&#x2F;nB<br>数据&#x2F;命令&#x2F;地址输入输出引脚I&#x2F;O0~I&#x2F;O7</p><h3 id="S5PV210支持的6种电源模式"><a href="#S5PV210支持的6种电源模式" class="headerlink" title="S5PV210支持的6种电源模式"></a>S5PV210支持的6种电源模式</h3><p>处理器有6种电源模式，可起到降低功耗的作用：<br>NORMAL：工作模式<br>IDLE：空闲模式<br>DEEPIDLE：深度空闲模式<br>STOP：停止模式<br>DEEPSTOP：深度停止模式<br>SLEEP：休眠模式</p><h3 id="S5PV210的3个主要的GPIO特殊功能寄存器功能"><a href="#S5PV210的3个主要的GPIO特殊功能寄存器功能" class="headerlink" title="S5PV210的3个主要的GPIO特殊功能寄存器功能"></a>S5PV210的3个主要的GPIO特殊功能寄存器功能</h3><p>常用的是前三个寄存器:<br>GPJ2CON：配置引脚为输入&#x2F;输出或其它功能<br>GPJ2DAT：装入准备输出或输入的数据，其值为7位[7:0]<br>GPJ2PUP：为10时对应引脚设置为禁止，01下拉，10上拉，其值为16位[15:0]</p><h3 id="S5PV210内部的定时器逻辑结构图"><a href="#S5PV210内部的定时器逻辑结构图" class="headerlink" title="S5PV210内部的定时器逻辑结构图"></a>S5PV210内部的定时器逻辑结构图</h3><p>![[Pasted image 20230413133411.png]]</p><h3 id="S5PV210定时器输出频率计算"><a href="#S5PV210定时器输出频率计算" class="headerlink" title="S5PV210定时器输出频率计算"></a>S5PV210定时器输出频率计算</h3><p>$$定时器输入时钟频率f{Tclk}&#x3D;\frac{f_{PCLK}}{预分频值+1}×分频值$$<br>$$PWM输出时钟频率&#x3D;\frac {f<br>{Tclk}}{T{CNTBn}}$$<br>$$PWM输出信号占空比&#x3D;\frac{TCMPBn}   {TCNTBn}$$<br>![[Pasted image 20230413163438.png]]</p><h3 id="S5PV210的-UART引脚信号"><a href="#S5PV210的-UART引脚信号" class="headerlink" title="S5PV210的 UART引脚信号"></a>S5PV210的 UART引脚信号</h3><p>S5PV210有4个UART(通用异步串行口)，<br>4个UART都可以在中断和DMA两种模式下进行收发，<br>都有遵从1.0规范的红外传输功能，<br>UART0有256字节的缓冲区，UART1有64字节缓冲区，UART2、3有16字节缓冲区，<br>接收器具有错误检测功能，可以检测出溢出错误，奇偶校验错误，帧错误和中止状况，每种情况下都会将一个错误标志在接收状态寄存器置位。</p><p>S5PV210的UART数据帧格式可通过线路控制寄存器(ULCONn)来编程设置</p><p>数据帧包含1个开始位、5到8个数据位、1个可选的奇偶校验位、1个或2个停止位。</p><table><thead><tr><th>开始位</th><th>数据位(5-8)</th><th>奇偶校验位</th><th>停止位(1-2)</th></tr></thead><tbody><tr><td>常设置成8N1(8数据有效位，无奇偶校验，1停止位)</td><td></td><td></td><td></td></tr></tbody></table><h3 id="S5PV210的-UART-波特率计算"><a href="#S5PV210的-UART-波特率计算" class="headerlink" title="S5PV210的 UART 波特率计算"></a>S5PV210的 UART 波特率计算</h3><p>UARTn的波特率取决于对应的波特率除数寄存器UBRDIVn的值<br>$$UBRDIVn&#x3D;(int)(CLK&#x2F;(bps<em>16))-1$$<br>CLK：所选择时钟源的频率<br>bps：波特率<br>如果波特率为115200bps且其时钟源PCLK 为40MHz<br>$$UBRDIVn &#x3D; (int)(40000000)&#x2F;(115200</em>16))-1<br>        &#x3D; (int)(21.7)-1 &#x3D; 21-1 &#x3D; 20$$<br>由于四舍五入的关系，实际波特率与理想波特率之间存在误差，实际使用时，传输10位数据的时间误差应该小于1.87％(3&#x2F;160)</p><h3 id="S5PV210的-LCD裸屏控制信号"><a href="#S5PV210的-LCD裸屏控制信号" class="headerlink" title="S5PV210的 LCD裸屏控制信号"></a>S5PV210的 LCD裸屏控制信号</h3><p>![[Pasted image 20230413180137.png]]</p><h3 id="S5PV210的-A-x2F-D转换与触摸屏接口逻辑结构"><a href="#S5PV210的-A-x2F-D转换与触摸屏接口逻辑结构" class="headerlink" title="S5PV210的 A&#x2F;D转换与触摸屏接口逻辑结构"></a>S5PV210的 A&#x2F;D转换与触摸屏接口逻辑结构</h3><p>![[Pasted image 20230413181221.png]]</p><h3 id="S5PV210的-IIC总线信号"><a href="#S5PV210的-IIC总线信号" class="headerlink" title="S5PV210的 IIC总线信号"></a>S5PV210的 IIC总线信号</h3><p>IIC(Inter-Integrated Circuit)，也写做I2C，即集成电路总线，是为实现在器件间进行简单的消息传递而设计的。</p><p>IIC总线只需要2个引脚，即串行数据线SDA和串行时钟线SCL。<br>总线空闲时，SDA和SCL为高电平。<br>启动数据传输时SCL保持为高，SDA由高变低，停止数据传输时SCL为高，SDA由低变高。<br>数据传输时，SCL为高期间，SDA必须保持稳定，数据的改变必须在SCL为低时完成， 时钟上升沿采集数据。</p><blockquote><p><a href="https://www.bilibili.com/video/BV1dg4y1H773/?spm_id_from=333.337.search-card.all.click&vd_source=62552d67d8de63c74ce35658499bc372">4分钟看懂！I2C通讯协议 最简单的总线通讯！_哔哩哔哩_bilibili</a></p></blockquote><p>Mini210s上的利用3路IIC连接了7种不同外设</p><h3 id="S5PV210的-SPI接口信号"><a href="#S5PV210的-SPI接口信号" class="headerlink" title="S5PV210的 SPI接口信号"></a>S5PV210的 SPI接口信号</h3><p>SPI(Serial Peripheral Interface)串行外围设备接口,是处理器与外设芯片间一种高速、低成本、易使用的全双工同步串行总线<br>SPI以主从方式工作，通常有一个主设备和一个或多个从设备<br>S5PV210最多可配置2个高速SPI接口<br>MOSI：主设备数据输出，从设备数据输入<br>MISO：主设备数据输入，从设备数据输出<br>SCLK：用来为数据通信提供同步时钟信号，由主设备产生<br>CSn：从设备使能信号，由主设备控制</p><blockquote><p><a href="https://www.bilibili.com/video/BV1F54y1M7e7/?spm_id_from=333.788.recommend_more_video.0&vd_source=62552d67d8de63c74ce35658499bc372">深入理解SPi通讯协议，5分钟看懂！_哔哩哔哩_bilibili</a></p></blockquote><h3 id="S5PV210的-SD主机控制器接口信号"><a href="#S5PV210的-SD主机控制器接口信号" class="headerlink" title="S5PV210的 SD主机控制器接口信号"></a>S5PV210的 SD主机控制器接口信号</h3><p>![[Pasted image 20230414002508.png]]<br>![[Pasted image 20230414002153.png]]</p><h3 id="要进行嵌入式系统调试的几种情况"><a href="#要进行嵌入式系统调试的几种情况" class="headerlink" title="要进行嵌入式系统调试的几种情况"></a>要进行嵌入式系统调试的几种情况</h3><p>1.通过JTAG小板或仿真器烧写启动代码<br>2.通过仿真器调试无操作系统的简单应用程序<br>3.通过仿真器调试操作系统与应用程序一体化的嵌入式系统<br>4.无法装入操作系统时通过仿真器调试硬件故障  </p><h3 id="嵌入式调试硬件连接图"><a href="#嵌入式调试硬件连接图" class="headerlink" title="嵌入式调试硬件连接图"></a>嵌入式调试硬件连接图</h3><p>![[Pasted image 20230414002336.png]]</p><h3 id="JTAG主要引脚信号"><a href="#JTAG主要引脚信号" class="headerlink" title="JTAG主要引脚信号"></a>JTAG主要引脚信号</h3><p>IEEE1149.1规定了JTAG的引脚信号，最主要的信号有4个：<br>TCK：时钟信号，输入<br>TMS：模式选择信号，输入，控制状态机的转换<br>TDI：数据输入信号<br>TDO：数据输出信号</p><h3 id="JTAG小板和仿真器-并口-的比较"><a href="#JTAG小板和仿真器-并口-的比较" class="headerlink" title="JTAG小板和仿真器(并口)的比较"></a>JTAG小板和仿真器(并口)的比较</h3><p>1.仿真器具有性能优势，JTAG小板下载文件所需的时间是仿真器的6倍以上</p><p>2.仿真器内部拥有存储器等资源，调试时不再利用系统除了边界扫描寄存器外的任何其他<br>资源(尤其是目标机CPU)，JTAG小板内部无资源 </p><p>3.仿真器的价格一般在千元左右，JTAG小板的价格一般在百元左右，存在将近10倍的差别</p><p>4.在与目标板的兼容方面，简易JTAG能够与多个调试软件兼容，而仿真器只能使用专门的调试软件，具有一定的局限性</p><p>5.通常JTAG小板用于烧写Flash,仿真器则用于单片机式的计算机系统调试<br>过去，JTAG烧写flash使用的都是这种方式，近来，由于台式机不再提供并口支持，也开始直接使用仿真器进行烧写</p><h2 id="第3章-Linux开发环境"><a href="#第3章-Linux开发环境" class="headerlink" title="第3章 Linux开发环境"></a>第3章 Linux开发环境</h2><h3 id="Linux被称为“GNU-x2F-Linux”的原因"><a href="#Linux被称为“GNU-x2F-Linux”的原因" class="headerlink" title="Linux被称为“GNU&#x2F;Linux”的原因"></a>Linux被称为“GNU&#x2F;Linux”的原因</h3><p>Linux只是一个内核，GNU软件为Linux操作系统的开发创造了一个合适的环境，因此Linux操作系统被称为“GNU&#x2F;Linux”</p><h3 id="Linux的文件权限"><a href="#Linux的文件权限" class="headerlink" title="Linux的文件权限"></a>Linux的文件权限</h3><p>文件权限设定命令chmod</p><pre><code class="hljs">chmod [-R] mode name</code></pre><p>其中，-R将指定目录及其子目录下面的所有文件，name为文件名或目录名。  </p><p>mode: 3个(文件拥有者u、组g、其他用户o、以上所有a)<br>8进制数字或rwx的组合<br>chmod 755 dir1，chmod u+x file2<br>chmod o-r file3，chmod a+x file4</p><blockquote><p>详见<a href="https://www.runoob.com/linux/linux-comm-chmod.html">Linux chmod 命令 | 菜鸟教程 (runoob.com)</a></p></blockquote><h3 id="gcc编译命令及选项的使用"><a href="#gcc编译命令及选项的使用" class="headerlink" title="gcc编译命令及选项的使用"></a>gcc编译命令及选项的使用</h3><p>![[Pasted image 20230414170429.png]]</p><p>| 编译目标| 编译命令|<br>| :—–:| :—-: | :—-: |<br>|hello.c| | |<br>|hello.i    |         gcc -E -o hello.i hello.c||<br>|hello.s    |         gcc -S  -o hello.s hello.i     |     gcc -S -o hello.s hello.c  |<br>|hello.o   |         gcc -c -o hello.o hello.s      |    gcc -c -o hello.o hello.c|<br>|hello     |          gcc -o hello hello.o            |     gcc -o hello hello.c |</p><blockquote><p>gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器。<br>gcc&#x2F;g++ 在执行编译工作的时候，总共需要4步：<br>1、预处理,生成 .i 的文件[预处理器cpp]<br>2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]<br>3、有汇编变为目标代码(机器代码)生成 .o 的文件[汇编器as]<br>4、连接目标代码, 生成可执行程序 [链接器ld]<br><a href="https://www.runoob.com/w3cnote/gcc-parameter-detail.html">GCC 参数详解 | 菜鸟教程 (runoob.com)</a></p></blockquote><h3 id="编译工具链的组成"><a href="#编译工具链的组成" class="headerlink" title="编译工具链的组成"></a>编译工具链的组成</h3><p>![[Pasted image 20230414172550.png]]</p><p><strong>GCC编译器</strong>：GNU的c和c++编译器，如gcc-2.95.3.tar.gz<br>gcc是编译的前端程序，编译时可依次调用cpp、cc1、as等工具完成编译。<br>gcc具有丰富的命令选项，如-o,-c,-L(指定库所在目录),-l(指定库文件),-I指定头文件目录),O(指定编译时的优化级别)等。</p><p><strong>binutils二进制工具</strong>：主要包括链接器ld，汇编代码编译器as，库管理器ar等工具，如binutils-2.11.2.tar.gz。</p><p><strong>glibc库函数</strong>：C函数库和Linux的线程库，如glibc-2.2.3.tar.gz和glibc-linuxthreads-2.2.3.tar.gz。</p><h3 id="共享函数库与静态函数库比较"><a href="#共享函数库与静态函数库比较" class="headerlink" title="共享函数库与静态函数库比较"></a>共享函数库与静态函数库比较</h3><p>分为静态函数库和共享函数库：  </p><h4 id="静态函数库："><a href="#静态函数库：" class="headerlink" title="静态函数库："></a>静态函数库：</h4><p>用.a作为文件的后缀，生成目标代码时会被加入到其中，生成代码体积大，速度快。  </p><h4 id="共享函数库："><a href="#共享函数库：" class="headerlink" title="共享函数库："></a>共享函数库：</h4><p>存放可执行程序在运行的时候才会被加载的函数，生成代码可以共享，便于升级<br>函数库名字必须lib作为前缀，后缀是.so(.a)及版本号信息， 如libgui.so.1。</p><h3 id="简单makefile文件编写"><a href="#简单makefile文件编写" class="headerlink" title="简单makefile文件编写"></a>简单makefile文件编写</h3><p>Makefile规则的一般形式如下：</p><pre><code class="hljs">target：dependency dependency(tab)&lt;command&gt; </code></pre><p>通常target即make最终需要创建的文件，但也可以是要执行的动作，如“clean”。<br>dependency列表，通常是编译目标文件所需要的其他文件。<br>command是创建target文件所需要执行的步骤，比如编译命令，每个命令占一行，起始字符必须为TAB字符。</p><p>example：</p><pre><code class="hljs">test：prog.o code.o    gcc –o test prog.o code.o prog.o：prog.c prog.h code.h    gcc –c prog.c –o prog.o code.o：code.c code.h    gcc –c code.c –o code.o clean：    rm –f *.o test</code></pre><p>左图的makefile文件中共定义了四个目标：test、prog.o、code.o和clean。<br>目标文件与依赖文件用”:”分隔，多个依赖文件以空格隔开，然后另起一行以tab开头给出实现目标的命令。<br>当命令过长时，使用”&quot;作为续行符。</p><p>在一行的开始给初变量名字，后面跟一个”:&#x3D;”及要设定的值，即可定义变量：</p><pre><code class="hljs">VARNAME:=string</code></pre><p>使用时把变量用括号括起来，并在前面加上  <code>$</code> ，即<code>$&#123;VARNAME&#125;</code><br>例：</p><pre><code class="hljs">OBJS:=prog.o code.oCC:=gcctest：$&#123; OBJS &#125;    $&#123; CC &#125; –o test $&#123; OBJS &#125;prog.o：prog.c prog.h code.h    $&#123; CC &#125; –c prog.c –o prog.ocode.o：code.c code.h    $&#123; CC &#125; –c code.c –o code.oclean：    rm –f $&#123; OBJS &#125; test</code></pre><h3 id="Shell中的位置参数与shift命令"><a href="#Shell中的位置参数与shift命令" class="headerlink" title="Shell中的位置参数与shift命令"></a>Shell中的位置参数与shift命令</h3><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>由出现在命令行上的位置确定的参数称做位置参数。<br>总共有十个位置参数，其对应的名称依次是$0,$1,$2,…$9，其中$0表示命令名或Shell脚本名，不可或缺，其它位置参数可有可无。</p><p>编辑ison脚本文件内容如下：</p><pre><code class="hljs">who | grep $1</code></pre><p>执行：</p><pre><code class="hljs">$   chmod +x ison$ ./ison bc</code></pre><p>shell会用bc代替$1，输出：</p><pre><code class="hljs"> who | grep bc</code></pre><h4 id="shift命令"><a href="#shift命令" class="headerlink" title="shift命令"></a>shift命令</h4><p>shift命令的作用是把位置参数左移，原来$1中的值丢失（$0不变），参数变量的个数自动减1。<br>编辑shiftdemo程序如下：</p><pre><code class="hljs">echo $# $*shiftecho $# $*    shiftecho $# $*shiftecho $# $*</code></pre><p>执行： </p><pre><code class="hljs">chmod +x shiftdemo./shiftdemo a b c</code></pre><p>输出：</p><pre><code class="hljs">$./shiftdemo a b c3 a b c2 b c1 c0$</code></pre><h3 id="简单shell程序编写"><a href="#简单shell程序编写" class="headerlink" title="简单shell程序编写"></a>简单shell程序编写</h3><p><a href="https://www.runoob.com/linux/linux-shell.html">https://www.runoob.com/linux/linux-shell.html</a></p><h2 id="第4章-嵌入式Linux开发环境"><a href="#第4章-嵌入式Linux开发环境" class="headerlink" title="第4章 嵌入式Linux开发环境"></a>第4章 嵌入式Linux开发环境</h2><h3 id="NFS的设定与作用"><a href="#NFS的设定与作用" class="headerlink" title="NFS的设定与作用"></a>NFS的设定与作用</h3><p>对于嵌入式系统调试，使用NFS非常方便，程序可以存放在主机上，被目标机上的Arm linux访问，省去了烧录和下载的过程。</p><p>NFS目录在主机的etc&#x2F;exports中指定，NFS可以在目标机linux启动后，通过mount使用，使用结束时需卸载。（如umount &#x2F;mnt）</p><h3 id="嵌入式Linux在NandFlash中的存储内容分布"><a href="#嵌入式Linux在NandFlash中的存储内容分布" class="headerlink" title="嵌入式Linux在NandFlash中的存储内容分布"></a>嵌入式Linux在NandFlash中的存储内容分布</h3><p>![[Pasted image 20230414200816.png]]</p><h3 id="台式计算机与嵌入式系统中的BootLoader"><a href="#台式计算机与嵌入式系统中的BootLoader" class="headerlink" title="台式计算机与嵌入式系统中的BootLoader"></a>台式计算机与嵌入式系统中的BootLoader</h3><p>![[Pasted image 20230414201111.png]]</p><h3 id="linux配置内核的命令及使用"><a href="#linux配置内核的命令及使用" class="headerlink" title="linux配置内核的命令及使用"></a>linux配置内核的命令及使用</h3><p>linux配置内核常用2个不同命令中的一个</p><pre><code class="hljs">make menuconfig  #不带图形界面make xconfig(gconfig)  #带图形界面</code></pre><p>嵌入式linux内核配置通常使用第一个命令，pc linux内核则通常使用第二个命令(需配置对应图形库)<br>命令执行的结果是产生一个 .config文件，并在编译过程中使其中定义的所有CONFIG_XXX起全局作用，根据这个生成不同的内核。<br>![[Pasted image 20230414204937.png]]</p><h3 id="什么是根文件系统"><a href="#什么是根文件系统" class="headerlink" title="什么是根文件系统"></a>什么是根文件系统</h3><p>Linux启动时挂载为根目录的文件系统，被称为根文件系统，是Linux不可或缺的组成部分。<br>根文件系统的具体形式就是就是我们平时看到的linux目录。<br>嵌入式系统常用的文件系统类型为cramfs和yaffs，根文件系统通常为cramfs。<br>mini210s使用了yaffs2文件系统。</p><h3 id="mini210s烧写的Linux过程，以及需要那些文件"><a href="#mini210s烧写的Linux过程，以及需要那些文件" class="headerlink" title="mini210s烧写的Linux过程，以及需要那些文件"></a>mini210s烧写的Linux过程，以及需要那些文件</h3><p>解压根文件系统：</p><pre><code class="hljs">tar xvzf /home/mini210s/Linux/rootfs_qtopia_qt4-20141212.tgz</code></pre><p>解压的根文件系统目录为：&#x2F;opt&#x2F;FriendlyARM&#x2F;mini210&#x2F;linux&#x2F;rootfs_mini210<br>解压制作根文件系统镜像的工具：</p><pre><code class="hljs">tar xvzf mktools-20200519.tar.gz -C /</code></pre><p>如需更改，我们可以更改该目录内容，并为其制作根文件系统镜像：</p><pre><code class="hljs">cd /opt/FriendlyARM/mini210/linux/mkyaffs2image-128M rootfs_mini210 rootfs_qtopia_qt4.img       //版本一mkyaffs2image_4k rootfs_mini210 rootfs_qtopia_qt4-slc4k.img  //版本二</code></pre><p>最后将生成的 rootfs_***.img 替换掉 SD卡 images&#x2F;Linux&#x2F;下的同名文件，再烧写到开发板即可</p><h2 id="第5章-控制嵌入式系统硬件"><a href="#第5章-控制嵌入式系统硬件" class="headerlink" title="第5章 控制嵌入式系统硬件"></a>第5章 控制嵌入式系统硬件</h2><h3 id="基于嵌入式linux的硬件控制编程流程图"><a href="#基于嵌入式linux的硬件控制编程流程图" class="headerlink" title="基于嵌入式linux的硬件控制编程流程图"></a>基于嵌入式linux的硬件控制编程流程图</h3><p>![[Pasted image 20230414205233.png]]</p><h3 id="Linux驱动程序与应用程序区别"><a href="#Linux驱动程序与应用程序区别" class="headerlink" title="Linux驱动程序与应用程序区别"></a>Linux驱动程序与应用程序区别</h3><h4 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h4><p>应用程序是一个进程，编程从主函数main()开始，主函数main()返回即是进程结束。</p><h4 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h4><p>驱动程序是一系列内核函数。驱动程序包含了一些函数，是内核的一部分，如open()、close()、read()、write()。这些函数由内核在适当的时候来调用，可以用来完成硬件访问等操作。</p><h3 id="加载Linux驱动程序的两种方式"><a href="#加载Linux驱动程序的两种方式" class="headerlink" title="加载Linux驱动程序的两种方式"></a>加载Linux驱动程序的两种方式</h3><h4 id="1-驱动程序直接编译入内核"><a href="#1-驱动程序直接编译入内核" class="headerlink" title="1 驱动程序直接编译入内核"></a>1 驱动程序直接编译入内核</h4><p>在内核启动时就已经在内存中<br>可以保留专用存储器空间</p><h4 id="2-驱动程序以模块形式存储在文件系统里，需要时动态载入内核"><a href="#2-驱动程序以模块形式存储在文件系统里，需要时动态载入内核" class="headerlink" title="2 驱动程序以模块形式存储在文件系统里，需要时动态载入内核"></a>2 驱动程序以模块形式存储在文件系统里，需要时动态载入内核</h4><p>按需加载，不用时节省内存<br>相对独立于内核，升级灵活<br>授权方式灵活  </p><h3 id="Linux下编译和链接生成的默认文件名是什么？"><a href="#Linux下编译和链接生成的默认文件名是什么？" class="headerlink" title="Linux下编译和链接生成的默认文件名是什么？"></a>Linux下编译和链接生成的默认文件名是什么？</h3><p>a.out</p><h3 id="Linux驱动程序编程"><a href="#Linux驱动程序编程" class="headerlink" title="Linux驱动程序编程"></a>Linux驱动程序编程</h3><p>![[Pasted image 20230414212306.png]]<br>![[Pasted image 20230414212320.png]]<br>![[Pasted image 20230414212333.png]]<br>![[Pasted image 20230414212349.png]]<br>![[Pasted image 20230414212406.png]]<br>![[Pasted image 20230414212429.png]]<br>![[Pasted image 20230414212442.png]]<br>![[Pasted image 20230414212550.png]]<br>![[Pasted image 20230414212605.png]]<br>![[Pasted image 20230414212617.png]]</p><h3 id="简述串口程序设计主要流程"><a href="#简述串口程序设计主要流程" class="headerlink" title="简述串口程序设计主要流程"></a>简述串口程序设计主要流程</h3><p>1.利用台式计算机，使用串口调试工具测试<br>正确设备电源及串行通信线，正确配置串口通信参数</p><p>2.连入嵌入式设备，使用串口通信程序测试<br>基于Linux的串口收发程序，或直接基于串口寄存器的串口通信程序(支持中断)</p><p>3.基于通信协议，编写编解码程序<br>要发送的数据需要编码，要接收的数据需要解码</p><p>4.基于串口通信数据的应用程序设计<br>使用图形用户界面完成对设备的控制，将采集数据可视化显示</p><h2 id="第6章-嵌入式系统应用编程"><a href="#第6章-嵌入式系统应用编程" class="headerlink" title="第6章 嵌入式系统应用编程"></a>第6章 嵌入式系统应用编程</h2><h3 id="使用命令生成QT程序的步骤及作用"><a href="#使用命令生成QT程序的步骤及作用" class="headerlink" title="使用命令生成QT程序的步骤及作用"></a>使用命令生成QT程序的步骤及作用</h3><p>使用命令行方式编译ARM的QT程序方法：<br>    # cd &#x2F;home&#x2F;mini210s&#x2F;qt&#x2F;helloworld<br>    # &#x2F;usr&#x2F;local&#x2F;Trolltech&#x2F;QtEmbedded-4.8.5-arm&#x2F;bin&#x2F;qmake -project<br>    # &#x2F;usr&#x2F;local&#x2F;Trolltech&#x2F;QtEmbedded-4.8.5-arm&#x2F;bin&#x2F;qmake<br>    # make<br>    # cp helloworld &#x2F;opt&#x2F;FriendlyARM&#x2F;mini210&#x2F;linux&#x2F;&#x2F;复制到NFS目录</p><p>生成可执行文件helloworld，需要在目标机上运行，命令为：<br>    # source setqt4env&#x2F;&#x2F;设置QT程序执行需要环境变量<br>    # mount -t nfs -o nolock,rsize&#x3D;1024,wsize&#x3D;1024 192.168.1.128:&#x2F;opt&#x2F;FriendlyARM&#x2F;mini210&#x2F;linux &#x2F;mnt<br>    # cd &#x2F;mnt<br>    # .&#x2F;helloworld -qws</p><h3 id="理解QT主程序"><a href="#理解QT主程序" class="headerlink" title="理解QT主程序"></a>理解QT主程序</h3>]]></content>
    
    
    
    <tags>
      
      <tag>技术碎片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人学大作业</title>
    <link href="/2023/03/15/robotics_homework/"/>
    <url>/2023/03/15/robotics_homework/</url>
    
    <content type="html"><![CDATA[<p>本文旨在记录HIT机器人学课程相关作业  </p><span id="more"></span><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>R-水平转动关节，<br>R1-垂直转动关节，<br>P-水平移动关节，<br>P1-垂直移动关节，</p><p>图示R1RR三关节机械臂，已知：结构参数为L1、L2、L3，连杆1、2、3的质量分别为m1、m2、m3，三连杆质量均集中连杆末端关节上。</p><p>我的作业是PPP1<br>即前两关节水平移动第三关节垂直移动</p><p>(1)试建立该机械臂坐标系并列写连接变量表。（10分）<br>(2)试推导机械臂末端连杆相对基座坐标系的齐次坐标变换矩阵。（10分）<br>(3)已知末端连杆位姿，推导该机械臂运动学逆解方程。（10分）<br>(4)已知各关节广义速度，试推导各连杆及质心在自身坐标系中描述的相对基系的广义速度计算方程。（10分）<br>(5)已知各关节广义加速度和重力加速度，试推导各连杆及质心的广义加速度计算方程。（10分）<br>(6)机械臂空载，推导各关节电机驱动力或力矩计算方程。（10分）</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术碎片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据课程相关资料汇总</title>
    <link href="/2023/03/02/Bigdata_resources/"/>
    <url>/2023/03/02/Bigdata_resources/</url>
    
    <content type="html"><![CDATA[<p>本文旨在记录HIT大数据智能控制课程相关资料  </p><span id="more"></span><p>授课老师王金宝</p><h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h2><h3 id="GFS-Google-File-System"><a href="#GFS-Google-File-System" class="headerlink" title="GFS(Google File System)"></a>GFS(Google File System)</h3><p><a href="https://www.bilibili.com/video/BV1fT411c7y6/?spm_id_from=333.337.search-card.all.click&vd_source=62552d67d8de63c74ce35658499bc372">解读Google分布式文件系统GFS（合集）_哔哩哔哩_bilibili</a><br><a href="https://blog.csdn.net/Yaoman753/article/details/123786807">(71条消息) 【分布式系统】GFS(Google File System )详解_gfs数据_猎猎风中的博客-CSDN博客</a></p><h3 id="Bigtable"><a href="#Bigtable" class="headerlink" title="Bigtable"></a>Bigtable</h3><p><a href="https://www.bilibili.com/video/BV1bj41137BY/?spm_id_from=333.337.search-card.all.click&vd_source=62552d67d8de63c74ce35658499bc372">【论文笔记】解读Google三驾马车之Bigtable（合集）_哔哩哔哩_bilibili</a></p><h3 id="Dynamo"><a href="#Dynamo" class="headerlink" title="Dynamo"></a>Dynamo</h3>]]></content>
    
    
    
    <tags>
      
      <tag>技术碎片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人控制理论课设知识意识流综合</title>
    <link href="/2023/01/03/robotic_control_advance/"/>
    <url>/2023/01/03/robotic_control_advance/</url>
    
    <content type="html"><![CDATA[<p>本文是为完成课设自学的意识流博客，主要供自己记录。如果有交流指正敬请不吝赐教。</p><span id="more"></span><h2 id="一阶惯性环节转换为数字滤波器推导"><a href="#一阶惯性环节转换为数字滤波器推导" class="headerlink" title="一阶惯性环节转换为数字滤波器推导"></a>一阶惯性环节转换为数字滤波器推导</h2><blockquote><p>前置知识：<br>课程：自动控制理论和信号处理基础（信号与系统）<br>知识点：了解Z变换，拉普拉斯变换和一阶惯性环节</p></blockquote><p>一阶惯性环节本身就是低通滤波器，可将一阶惯性环节改为  $$\Phi(s)&#x3D;\frac{U_{o}(s)}{U_{i}(s)}&#x3D;\frac{1}{RCs+1}&#x3D;\frac{\omega_{c}}{s+\omega_{c}} $$ ，其中  $\omega_{c}&#x3D;\frac{1}{RC}$  为截止频率。为了便于在C语言中实现一阶低通滤波，将其离散化，使用一阶向后差分  $s&#x3D;\frac{1-z^{-1}}{T_{s}}$  ，可得</p><p>$$\begin{array}{l}<br>\phi(z)&#x3D;\frac{Y(z)}{X(z)}&#x3D;\frac{\omega_{c}}{\frac{1-Z^{-1}}{T_{s}}+\omega_{c}}&#x3D;\frac{T_{s} \omega_{c}}{\left(1-Z^{-1}\right)+T_{s} \omega_{c}} \<br>Y(z)\left(\left(1-Z^{-1}\right)+T_{s} \omega_{c}\right)&#x3D;X(z) T_{s} \omega_{c} \<br>Y(n)-Y(n-1)+Y(n) T_{s} \omega_{c}&#x3D;X(n) T_{s} \omega_{c} \<br>Y(n)&#x3D;\frac{1}{\left(1+T_{s} \omega_{c}\right)} Y(n-1)+\frac{T_{s} \omega_{c}}{\left(1+T_{s} \omega_{c}\right)} X(n) \<br>Y(n)&#x3D;Y(n-1)-\frac{T_{s} \omega_{c}}{\left(1+T_{s} \omega_{c}\right)} Y(n-1)+\frac{T_{s} \omega_{c}}{\left(1+T_{s} \omega_{c}\right)} X(n) \<br>Y(n)&#x3D;Y(n-1)+\frac{T_{s} \omega_{c}}{\left(1+T_{s} \omega_{c}\right)}(X(n)-Y(n-1))<br>\end{array}$$</p><p>化简成这样后，低通滤波就可以使用两个加减法和一个乘法实现，写成C语言形式，可以化为</p><p>$$Y(n)+&#x3D;\frac{\omega_{c}}{\left(f_{s}+\omega_{c}\right)}(X(n)-Y(n-1))$$<br>这里可以给出结论，同样的具有一定频率的信号输入(低通滤波器对直流量无效)，$\frac{Ts\omega c}{1+Ts\omega c}$越大，说明这个低通滤波器的截止频率越大，滤波效果降低；反之，滤波效果增强，但随之而来的是信号的失真程度增大，各有利弊，需要根据不同的应用需求确定该滤波系数的大小。</p><h2 id="机器人交互控制"><a href="#机器人交互控制" class="headerlink" title="机器人交互控制"></a>机器人交互控制</h2><p>1.直接力控 Direct force control</p><p>2.间接力控 Indirect force control<br>2.1柔顺控制 Compliance control<br>2.1.1被动柔顺 Passive compliance<br>2.1.2主动柔顺 Active compliance</p><h3 id="2-2阻抗-x2F-导纳控制-Admittance-x2F-Impedance-control"><a href="#2-2阻抗-x2F-导纳控制-Admittance-x2F-Impedance-control" class="headerlink" title="2.2阻抗&#x2F;导纳控制 Admittance&#x2F;Impedance control"></a>2.2阻抗&#x2F;导纳控制 Admittance&#x2F;Impedance control</h3><blockquote><p>参考资料：<br><a href="https://zhuanlan.zhihu.com/p/126338809">阻抗&#x2F;导纳控制最强解析 - 知乎 (zhihu.com)</a><br><a href="https://www.aiimooc.com/mall/preshow-htm-itemid-660.html">机器人阻抗控制及其在人机协作中的应用_睿慕课 (aiimooc.com)</a><br><a href="https://www.zhihu.com/question/43633361/answer/124417009">阻抗控制的实现方式应该是多种多样的，请能否概述一下大概有几种方式以及主流的方法？-知乎 </a></p></blockquote><p>考虑到力的影响，光使用位置控制来控制机器人的关节必然会出现误差，引起环境或机器人的损坏。此时我们就要引入<strong>柔顺</strong>，即类似弹簧一样的力与位置间关系，来防止控制器无上限的输出力矩。</p><p>但是机器人不能总是有弹簧相助，而且弹簧的刚度不能按需调节，也很难做到各向异性（在不同方向上有不同的刚度）。所以希望能用控制算法让机器臂表现出想要的柔性。也就是实际上是由控制算法实现的弹性系统。最简单的有弹性、而且不会永久震荡的系统就是<em><strong>Mass-Spring-Damper（质量-弹簧-阻尼系统）</strong></em>。</p><p>动力学方程即$$M \ddot{x}+b \dot{x}+k x&#x3D;F+F_{e x t}$$<br>其中<br>$M：质量，b：阻尼参数，k：弹性系数，x:位移，F：系统恒力，F_{e x t}：突加外力$<br>阻抗控制&#x2F;导纳控制的核心思想就是使用一个控制器来模拟这样一个有弹性的系统。</p><ol><li><p>测量当前位置和目标位置的差，调整末端产生的力（一般通过调整各关节力矩实现）。这种通常称为导纳控制或刚度控制。</p></li><li><p>测量末端受到的力，调整末端的速度。这种常称为阻抗控制。</p></li></ol><h4 id="2-2-1关节空间-Joint-space"><a href="#2-2-1关节空间-Joint-space" class="headerlink" title="2.2.1关节空间 Joint space"></a>2.2.1关节空间 Joint space</h4><p> 目标 : 让机器人的每一个关节都体现出由弹簧-阻尼-质量组成的二阶系统的动态特性。</p><p>$$\boldsymbol{M}<em>{d} \ddot{\tilde{\boldsymbol{q}}}+\boldsymbol{D}</em>{d} \dot{\tilde{\boldsymbol{q}}}+\boldsymbol{K}<em>{d} \tilde{\boldsymbol{q}}&#x3D;\boldsymbol{\tau}</em>{e x t}, \quad \tilde{\boldsymbol{q}}&#x3D;\boldsymbol{q}_{d}-\boldsymbol{q}<br>$$</p><ul><li>机器人动力学方程:</li></ul><p>$$\boldsymbol{M}(\boldsymbol{q}) \ddot{q}+\boldsymbol{C}(\dot{\boldsymbol{q}}, \boldsymbol{q}) \dot{\boldsymbol{q}}+\boldsymbol{g}<em>{\boldsymbol{k}}(\boldsymbol{q})&#x3D;\boldsymbol{\tau}-\boldsymbol{\tau}</em>{\text {ext }}<br>$$<br>其中$q:关节位置，\dot{\boldsymbol{q}}：关节角速度，\ddot{\boldsymbol{q}}：关节角加速度，M(q)：关节惯性矩阵，C(\dot{\boldsymbol{q}},q)：关节科里奥利矩阵，g_k(q)：重力矩阵$</p><ul><li>假定机器人的控制任务是跟随一条提前规划的轨迹， 即：  $$\ddot{\boldsymbol{q}}<em>{d}, \dot{\boldsymbol{q}}</em>{d}, \boldsymbol{q}_{d} $$</li><li>则可定义如下的关节转矩控制输入:<br>$$<br>\begin{aligned}<br>\boldsymbol{\tau}&#x3D; &amp; \boldsymbol{M}(\boldsymbol{q}) \ddot{\boldsymbol{q}}<em>{d}+\boldsymbol{C}(\dot{\boldsymbol{q}}, \boldsymbol{q}) \dot{\boldsymbol{q}}+\boldsymbol{g}(\boldsymbol{q}) \<br>&amp; +\boldsymbol{M}(\boldsymbol{q}) \boldsymbol{M}</em>{d}^{-1}\left(\boldsymbol{D}<em>{d} \dot{\tilde{\boldsymbol{q}}}+\boldsymbol{K}</em>{d} \tilde{\boldsymbol{q}}\right)+\left(\boldsymbol{I}-\boldsymbol{M}(\boldsymbol{q}) \boldsymbol{M}<em>{d}^{-1}\right) \boldsymbol{\tau}</em>{e x t}<br>\end{aligned}<br>$$</li><li>将上式代回机器人动力学方程，消去相同项，等式两边分别乘以  $M^{-1}(\boldsymbol{q}), M_{d}$  整理后可得到所期望的二阶系统动态方程。</li></ul><h4 id="2-2-2笛卡尔空间-Cartesian-space"><a href="#2-2-2笛卡尔空间-Cartesian-space" class="headerlink" title="2.2.2笛卡尔空间 Cartesian space"></a>2.2.2笛卡尔空间 Cartesian space</h4><h4 id="2-2-3-例子"><a href="#2-2-3-例子" class="headerlink" title="2.2.3 例子"></a>2.2.3 例子</h4><blockquote><p>参考哈尔滨工业大学邢宏军硕士学位论文《基于主被动柔顺的机器人旋拧阀门作业研究》</p></blockquote><p>机器人与环境间的接触力与机器人位移的动态关系设为为质量-弹簧-阻尼系统, 即:</p><p>$$\boldsymbol{F}<em>{e}&#x3D;\boldsymbol{M}</em>{e}\left(\ddot{\boldsymbol{X}}-\ddot{\boldsymbol{X}}<em>{e}\right)+\boldsymbol{B}</em>{e}\left(\dot{\boldsymbol{X}}-\dot{\boldsymbol{X}}<em>{e}\right)+\boldsymbol{K}</em>{e}\left(\boldsymbol{X}-\boldsymbol{X}_{e}\right)$$</p><p>式中:  $\boldsymbol{S}<em>{e}&#x3D;\left{\boldsymbol{X}</em>{e}(t), \dot{\boldsymbol{X}}<em>{e}(t), \ddot{\boldsymbol{X}}</em>{e}(t)\right}$  一一环境位置变化轨迹;<br> $\boldsymbol{M}<em>{e}, \boldsymbol{B}</em>{e}, \boldsymbol{K}_{e}$  一一分别表示环境惯性、阻尼和刚度矩阵。</p><p>由于在旋拧阀门过程中, 机器人的关节运动缓慢, 因此, 可以忽略机器人末端运动速度  $\dot{\boldsymbol{X}}$  和加速度  $\ddot{\boldsymbol{X}}$ 。同时, 尽管在旋拧过程中, 阀门手轮的位置(环境位置)一直处于移动状态, 但移动缓慢, 可忽略环境位移的速度  $\dot{\boldsymbol{X}}<em>{e}$ 和加速度  $\ddot{\boldsymbol{X}}</em>{e}$  影响。</p><p>综上, 本文在分析过程中, 将机器人末端与环境间的接触模型简化为:</p><p>$$\boldsymbol{F}<em>{e}&#x3D;\left{\begin{array}{ll}<br>\boldsymbol{K}</em>{e}\left(\boldsymbol{X}-\boldsymbol{X}<em>{e}\right) &amp; \boldsymbol{X} \geq \boldsymbol{X}</em>{e} \<br>0 &amp; \boldsymbol{X}&lt;\boldsymbol{X}_{e}<br>\end{array}\right.$$</p><h4 id="2-2-4-自适应阻抗控制"><a href="#2-2-4-自适应阻抗控制" class="headerlink" title="2.2.4 自适应阻抗控制"></a>2.2.4 自适应阻抗控制</h4><h4 id="2-2-5-例子"><a href="#2-2-5-例子" class="headerlink" title="2.2.5 例子"></a>2.2.5 例子</h4><p>在实际旋拧阀门过程中, 无法实时获得阀门手轮的实际环境位置  $x_{e}(t)$ , 由此 导致无法准确设定机器人控制的参考位置 $x_{r}(t)$ , 从而使设计系统存在跟踪误差。本部分利用自适应控制实时计算参考位置  $x_{r}(t)$  以实现对期望作用力  $f_{d}$  的跟踪。自适应控制中设计的机器人参考位置偏移量是力跟踪误差  e  的函数, 如式(4-21)所示。</p><p>$$x_{r}(t)&#x3D;g(t)+k_{p}(t) e(t)+k_{d}(t) \dot{e}(t)$$</p><p>式中,  $k_{p}(t)$  和  $k_{d}(t)$  分别是作用在力误差上的自适应比例和微分反馈增益,  $g(t)$是自适应控制方法产生的辅助位置信号。由式(4-10)可知, 当期望力恒定时, 力误差动力学模型可简化为:</p><p>$$m \ddot{e}+b \dot{e}+\left(k+k_{e}\right) e&#x3D;k f_{d}+m k_{e} \ddot{x}<em>{e}+b k</em>{e} \dot{x}<em>{e}+k k</em>{e} x_{e}-k k_{e} x_{r}<br>$$<br>将式(4-21)代入式(4-22)中, 可得:</p><p>$$\ddot{e}+\frac{b+k k_{e} k_{d}(t)}{m} \dot{e}+\frac{k+k_{e}+k k_{e} k_{p}(t)}{m} e&#x3D;\frac{k\left(f_{d}+k_{e} x_{e}\right)+m k_{e} \ddot{x}<em>{e}+b k</em>{e} \dot{x}<em>{e}-k k</em>{e} g(t)}{m}$$</p><p>式(4-23)表示的即是 MRAC 系统中的可调被控对象。为便于分析, 将式(4-23) 简化为:</p><p>$$\ddot{e}(t)+a(t) \dot{e}(t)+b(t) e(t)&#x3D;f(t)$$</p><p>式中:</p><p>$$\begin{array}{l}<br>a(t)&#x3D;\left[b+k k_{e} k_{d}(t)\right] &#x2F; m \<br>b(t)&#x3D;\left[k+k_{e}+k k_{e} k_{p}(t)\right] &#x2F; m \<br>f(t)&#x3D;\left[k\left(f_{d}+k_{e} x_{e}\right)+m k_{e} \ddot{x}<em>{e}+b k</em>{e} \dot{x}<em>{e}-k k</em>{e} g(t)\right] &#x2F; m<br>\end{array}<br>$$<br>假定力跟踪误差的理想动态模型为:<br>$$<br>\ddot{e}<em>{m}(t)+2 \zeta \omega \dot{e}</em>{m}(t)+\omega^{2} e_{m}(t)&#x3D;0<br>$$<br>式中, $\zeta, \omega$  分别为用户自定义的阻尼比和无阻尼自然频率。<br>由式(4-24)和式(4-25) 可知:<br>$$<br>\left(\ddot{e}-\ddot{e}<em>{\mathrm{m}}\right)+2 \zeta \omega\left(\dot{e}-\dot{e}</em>{m}\right)+\omega^{2}\left(e-e_{m}\right)&#x3D;f+(2 \zeta \omega-a) \dot{e}+\left(\omega^{2}-b\right) e<br>$$<br>式(4-26)的状态空间形式为:<br>$$<br>\dot{E}&#x3D;\left[\begin{array}{cc}0 &amp; 1 \-\omega^{2} &amp; -2 \zeta \omega<br>\end{array}\right] E+\left[\begin{array}{cc}0 &amp; 0 \\omega^{2}-b &amp; 2 \zeta \omega-a<br>\end{array}\right]\left[\begin{array}{l}e \\dot{e} \end{array}\right]+\left[\begin{array}{l}0 \f<br>\end{array}\right]<br>$$<br>式中,  $E&#x3D;\left[\left(e-e_{m}\right),\left(\dot{e}-\dot{e}_{m}\right)\right]^{\mathrm{T}}$  是  $2 \times 1$  阶跟踪误差向量。构造正标量 Lyapunov 候补函数 V  :</p><p>$$V&#x3D;E^{T} P E+Q_{0}\left(f-f^{<em>}\right)^{2}+Q_{1}\left(\omega^{2}-b+b^{</em>}\right)^{2}+Q_{2}\left(2 \zeta \omega-a+a^{<em>}\right)^{2}<br>$$<br>式中,  $\left[f^{</em>}, b^{<em>}, a^{</em>}\right]$  是待定义时间函数, $\left[Q_{0}, Q_{1}, Q_{2}\right]$  是正标量,  $P&#x3D;\left[\begin{array}{ll}p_{1} &amp; p_{2} \ p_{2} &amp; p_{3}\end{array}\right]$  是  $2 \times 2$ 阶正定对称矩阵且满足 Lyapunov 方程, 即:</p><p>$$\left[\begin{array}{ll}<br>p_{1} &amp; p_{2} \<br>p_{2} &amp; p_{3}<br>\end{array}\right]\left[\begin{array}{cc}<br>0 &amp; 1 \<br>-\omega^{2} &amp; -2 \zeta \omega<br>\end{array}\right]+\left[\begin{array}{cc}<br>0 &amp; -\omega^{2} \<br>1 &amp; -2 \zeta \omega<br>\end{array}\right]\left[\begin{array}{ll}<br>p_{1} &amp; p_{2} \<br>p_{2} &amp; p_{3}<br>\end{array}\right]&#x3D;-\left[\begin{array}{ll}<br>q_{1} &amp; q_{2} \<br>q_{2} &amp; q_{3}<br>\end{array}\right]<br>$$<br>其中,  $Q&#x3D;\left[\begin{array}{ll}q_{1} &amp; q_{2} \ q_{2} &amp; q_{3}\end{array}\right]$  是正定对称矩阵。则 Lyapunov 候补函数  V  的导数为:<br>$$<br>\begin{aligned}<br>\dot{V}&#x3D; &amp; -E^{T} Q E+\left[2 Q_{0} f\left(\dot{f}-\dot{f}^{<em>}\right)+2 q f-2 Q_{0} f^{</em>}\left(\dot{f}-\dot{f}^{<em>}\right)\right]+ \<br>&amp; {\left[2 Q_{1}\left(b-\omega^{2}\right)\left(\dot{b}-\dot{b}^{</em>}\right)-2 q\left(b-\omega^{2}\right) e-2 Q_{1} b^{<em>}\left(\dot{b}-\dot{b}^{</em>}\right)\right]+} \<br>&amp; {\left[2 Q_{2}(a-2 \zeta \omega)\left(\dot{a}-\dot{a}^{<em>}\right)-2 q(a-2 \zeta \omega) \dot{e}-2 Q_{2} a^{</em>}\left(\dot{a}-\dot{a}^{<em>}\right)\right] }<br>\end{aligned}<br>$$<br>其中,  $q&#x3D;p_{2} e+p_{3} \dot{e}$  。为保证式(4-29)的渐进稳定性, 设定:<br>$$<br>\begin{array}{l}<br>2 Q_{0} f\left(\dot{f}-\dot{f}^{</em>}\right)+2 q f&#x3D;0 \<br>2 Q_{1}\left(b-\omega^{2}\right)\left(\dot{b}-\dot{b}^{<em>}\right)-2 q\left(b-\omega^{2}\right) e&#x3D;0 \<br>2 Q_{2}(a-2 \zeta \omega)\left(\dot{a}-\dot{a}^{</em>}\right)-2 q(a-2 \zeta \omega) \dot{e}&#x3D;0<br>\end{array}<br>$$<br>即:<br>$$<br>\begin{array}{l}<br>\dot{f}-\dot{f}^{<em>}&#x3D;-\frac{1}{Q_{0}} q \<br>\dot{b}-\dot{b}^{</em>}&#x3D;\frac{1}{Q_{1}} q e \<br>\dot{a}-\dot{a}^{<em>}&#x3D;\frac{1}{Q_{2}} q \dot{e}<br>\end{array}<br>$$<br>由式(4-32)可知, 式(4-30)可变化为:<br>$$<br>\dot{V}&#x3D;-E^{T} Q E+2 f^{</em>} q-2 b^{<em>} q e-2 a^{</em>} q \dot{e}<br>$$<br>为保证 $\dot{V}&lt;0$ , 对  $f^{<em>}, a^{</em>}  和  b^{<em>}$  作如下设定:<br>$$<br>\begin{array}{l}<br>f^{</em>}&#x3D;-Q_{0}^{<em>} q \<br>b^{</em>}&#x3D;Q_{1}^{<em>} q e \<br>a^{</em>}&#x3D;Q_{2}^{<em>} q \dot{e}<br>\end{array}<br>$$<br>其中,  $Q_{0}^{</em>}, Q_{1}^{<em>}$  和  $Q_{2}^{</em>}$  为非负常数。根据式(4-34), 式(4-33)可改写为<br>$$<br>\dot{V}&#x3D;-E^{T} Q E-2 Q_{0}^{<em>} q^{2}-2 Q_{1}^{</em>}(q e)^{2}-2 Q_{2}^{<em>}(q \dot{e})^{2}<br>$$<br>由此可知  $\dot{V}&lt;0$ , 即  $\dot{V}$  负定, 根据 Lyapunov 稳定理论可知, 该系统是稳定的。 由式(4-32)和式(4-34)可知, 系统稳定时, 自适应控制率中的参数  $f, a$  和  $b$  应分别取为:<br>$$<br>\begin{array}{l}<br>\dot{f}&#x3D;-\frac{1}{Q_{0}} q-Q_{0}^{</em>} \frac{d}{d t}[q] \<br>\dot{b}&#x3D;\frac{1}{Q_{1}} q e+Q_{1}^{<em>} \frac{d}{d t}[q e] \<br>\dot{a}&#x3D;\frac{1}{Q_{2}} q \dot{e}+Q_{2}^{</em>} \frac{d}{d t}[q \dot{e}]<br>\end{array}<br>$$<br>对上式积分, 可得:<br>$$<br>\begin{array}{l}<br>f(t)&#x3D;f(0)-\frac{1}{Q_{0}} \int_{0}^{t} q(t) d t-Q_{0}^{<em>} q(t) \<br>b(t)&#x3D;b(0)+\frac{1}{Q_{1}} \int_{0}^{t} q(t) e(t) d t+Q_{1}^{</em>} q(t) e(t) \<br>a(t)&#x3D;a(0)+\frac{1}{Q_{2}} \int_{0}^{t} q(t) \dot{e}(t) d t+Q_{2}^{<em>} q(t) \dot{e}(t)<br>\end{array}<br>$$<br>其中,  $q(t)&#x3D;p_{2} e(t)+p_{3} \dot{e}(t)$  。<br>由式(4-23)和式(4-24)可知, 为保证系统是 Lyapunov意义下稳定的, 可将式(4-21) 中的参数  $\left[g(t), k_{p}(t), k_{a}(t)\right]$  进行如下设计:<br>$$<br>\begin{array}{l}<br>g(t)&#x3D;g(0)+\alpha_{1} \int_{0}^{t} q(t) d t+\alpha_{2} q(t) \<br>k_{p}(t)&#x3D;k_{p}(0)+\beta_{1} \int_{0}^{t} q(t) e(t) d t+\beta_{2} q(t) e(t) \<br>k_{d}(t)&#x3D;k_{d}(0)+\gamma_{1} \int_{0}^{t} q(t) \dot{e}(t) d t+\gamma_{2} q(t) \dot{e}(t) \<br>q(t)&#x3D;\lambda_{\rho} e(t)+\lambda_{d} \dot{e}(t)<br>\end{array}<br>$$<br>其中,  $\left(\lambda_{p}, \lambda_{d}\right)$  分别为正的位置和速度加权因子,  $\left(\alpha_{1}, \beta_{1}, \gamma_{1}\right)$  为正的积分自适应增益,  $\left(\alpha_{2}, \beta_{2}, \gamma_{2}\right)$  为非负的比例自适应增益,  $\left[g(0), k_{p}(0), k_{d}(0)\right]$  为各参数的初始值。 结合式(4-38), 对式(4-21)进行适当改变, 可写成:<br>$$<br>x_{r}(t)&#x3D;x_{r}(0)+k_{p}^{</em>}(t) e(t)+k_{i}^{<em>} \int_{0}^{t} e(t) d t+k_{d}^{</em>} \dot{e}(t)<br>$$<br>其中,  $k_{p}^{<em>}&#x3D;\alpha_{1} \lambda_{d}+\alpha_{2} \lambda_{p}+k_{p}(t), k_{i}^{</em>}&#x3D;\alpha_{1} \lambda_{p}, k_{d}^{*}&#x3D;\alpha_{2} \lambda_{d}+k_{d}(t)$  且  $x_{r}(0)&#x3D;g(0)$  。<br>通过以上分析可知, 参考位置  $x_{r}(t)$  实际上是由关于力跟踪误差  $e(t)$  的一种 PID 控制器生成的。该控制器中, 积分项 I 的系数为常量增益, 比例微分项 PD 系数为s自适应增。<br>以上所述即为本文采用的自适应阻抗控制策略, 值得注意的是, 本控制器中 不含有环境位置  $x_{e}$  和环境刚度  $k_{e}$ , 并可以基于力跟踪误差性能指标  $e, \dot{e}$  对控制系统 进行在线调节。因此, 本文所设计的自适应阻抗控制方法可以快速适应大幅度的环境位置或环境刚度突变。</p><p>3.力&#x2F;位混合控制 Hybrid position&#x2F;force control</p><h2 id="最优控制理论在倒立摆系统中的应用"><a href="#最优控制理论在倒立摆系统中的应用" class="headerlink" title="最优控制理论在倒立摆系统中的应用"></a>最优控制理论在倒立摆系统中的应用</h2><p>状态反馈矩阵的求解过程<br>寻找控制率u，使得J最小<br>$$\begin{aligned}<br>J&#x3D;\psi\left[x\left(t_{f}\right)\right] &amp; +\int_{t_{0}}^{t_{f}} L[x(t), u(t), t] d t \<br>\text { subject to } \dot{x} &amp; &#x3D;f(x(t), u(t), t) \<br>x\left(t_{o}\right) &amp; &#x3D;x_{o}<br>\end{aligned}$$<br>用成本向量  $\lambda$ , 引入新的代价函数:<br>$$<br>\bar{J}&#x3D;\psi\left[x\left(t_{f}\right)\right]+\int_{t_{0}}^{t_{f}}\left[L+\lambda^{T}(f-\dot{x})\right] d t<br>$$<br>显然, 成本向量  $\lambda$  可以任意取值, 因为:<br>$$<br>f-\dot{x}&#x3D;0<br>$$<br>沿着最优路径, $J$和  $\bar{J}$  的变化应该消失 (等于 0 )<br>$$<br>\delta \bar{J}&#x3D;\psi_{x} \delta x\left(t_{f}\right)+\int_{t_{o}}^{t_{f}}\left[L_{x} \delta x+L_{u} \delta u+\lambda^{T} f_{x} \delta x+\lambda^{T} f_{u} \delta u-\lambda^{T} \delta \dot{x}\right] d t,<br>$$<br>其中, 下标代表偏导数。<br>用成本向量  $\lambda$ , 引入新的代价函数:<br>$$<br>\bar{J}&#x3D;\psi\left[x\left(t_{f}\right)\right]+\int_{t_{0}}^{t_{f}}\left[L+\lambda^{T}(f-\dot{x})\right] d t<br>$$<br>显然, 成本向量  $\lambda$  可以任意取值, 因为:<br>$$<br>f-\dot{x}&#x3D;0<br>$$<br>沿着最优路径, $J$和  $\bar{J}$  的变化应该消失 (等于 0 )<br>$$<br>\delta \bar{J}&#x3D;\psi_{x} \delta x\left(t_{f}\right)+\int_{t_{o}}^{t_{f}}\left[L_{x} \delta x+L_{u} \delta u+\lambda^{T} f_{x} \delta x+\lambda^{T} f_{u} \delta u-\lambda^{T} \delta \dot{x}\right] d t,<br>$$<br>其中, 下标代表偏导数。利用分部积分法:<br>$$<br>-\int_{t_{o}}^{t_{f}} \lambda^{T} \delta \dot{x} d t&#x3D;-\lambda^{T}\left(t_{f}\right) \delta x\left(t_{f}\right)+\lambda^{T}\left(t_{o}\right) \delta x\left(t_{o}\right)+\int_{t_{o}}^{t_{f}} \dot{\lambda}^{T} \delta x d t,<br>$$<br>将分部积分法的表达式, 带入  $\bar{J}$  的变化量表达式中:<br>$$<br>\begin{aligned}<br>\delta \bar{J}&#x3D; &amp; \psi_{x}\left(x\left(t_{f}\right)\right) \delta x\left(t_{f}\right)+\int_{t_{o}}^{t_{f}}\left(L_{u}+\lambda^{T} f_{u}\right) \delta u d t+ \<br>&amp; \int_{t_{o}}^{t_{f}}\left(L_{x}+\lambda^{T} f_{x}+\dot{\lambda}^{T}\right) \delta x d t-\lambda^{T}\left(t_{f}\right) \delta x\left(t_{f}\right)+\lambda^{T}\left(t_{o}\right) \delta x\left(t_{o}\right) .<br>\end{aligned}<br>$$<br> $\lambda^{T}\left(t_{o}\right) \delta x\left(t_{o}\right)$  等于0, 因为初始状态是常数。<br> $$<br>\begin{aligned}<br>\delta \bar{J}&#x3D; &amp; \psi_{x}\left(x\left(t_{f}\right)\right) \delta x\left(t_{f}\right)+\int_{t_{o}}^{t_{f}}\left(L_{u}+\lambda^{T} f_{u}\right) \delta u d t+ \<br>&amp; \int_{t_{o}}^{t_{f}}\left(L_{x}+\lambda^{T} f_{x}+\dot{\lambda}^{T}\right) \delta x d t-\lambda^{T}\left(t_{f}\right) \delta x\left(t_{f}\right)<br>\end{aligned}<br>$$<br>为了保证增量为 0 , 增量表达式中的三个组成部分, 就应该分别<br>等于0:<br>$$<br>\begin{aligned}<br>L_{u}+\lambda^{T} f_{u} &amp; &#x3D;0 \<br>L_{x}+\lambda^{T} f_{x}+\dot{\lambda}^{T} &amp; &#x3D;0 \<br>\psi_{x}\left(x\left(t_{f}\right)\right)-\lambda^{T}\left(t_{f}\right) &amp; &#x3D;0 .<br>\end{aligned}<br>$$<br>第二项和第三项, 可以重新写为下式:<br>$$<br>\begin{aligned}<br>\dot{\lambda}^{T} &amp; &#x3D;-L_{x}-\lambda^{T} f_{x} \<br>\lambda_{T}\left(t_{f}\right) &amp; &#x3D;\psi_{x}\left(x\left(t_{f}\right)\right) .<br>\end{aligned}<br>$$<br>针对线性二次型调节器 (LQR)：<br>$$<br>L&#x3D;\frac{1}{2} x^{T} Q x+\frac{1}{2} u^{T} R u,<br>$$<br>对比最一般的表达式:<br>$$<br>\delta \bar{J}&#x3D;\psi_{x} \delta x\left(t_{f}\right)+\int_{t_{o}}^{t_{f}}\left[L_{x} \delta x+L_{u} \delta u+\lambda^{T} f_{x} \delta x+\lambda^{T} f_{u} \delta u-\lambda^{T} \delta \dot{x}\right] d t,<br>$$<br>可以得到如下结果:<br>$$<br>\begin{aligned}<br>L_{x} &amp; &#x3D;x^{T} Q \<br>L_{u} &amp; &#x3D;u^{T} R \<br>f_{x} &amp; &#x3D;A \<br>f_{u} &amp; &#x3D;B,<br>\end{aligned}<br>$$<br>对比最优路径上, 增量为 0 的结论:<br>$$<br>\begin{array}{l}<br>\begin{array}{ll}<br>L_{u}+\lambda^{T} f_{u}&#x3D;0 &amp; L_{x}&#x3D;x^{T} Q \<br>L_{u}&#x3D;u^{T} R<br>\end{array} \<br>L_{x}+\lambda^{T} f_{x}+\dot{\lambda}^{T}&#x3D;0 \quad f_{x}&#x3D;A \<br>\psi_{x}\left(x\left(t_{f}\right)\right)-\lambda^{T}\left(t_{f}\right)&#x3D;0 . \quad f_{u}&#x3D;B, \<br>\dot{x}&#x3D;A x+B u \<br>\text { 可以得到如下结果: } \<br>x\left(t_{o}\right)&#x3D;x_{o} \<br>\dot{\lambda}&#x3D;-Q x-A^{T} \lambda \<br>\lambda\left(t_{f}\right)&#x3D;0 \<br>R u+B^{T} \lambda&#x3D;0 . \<br>\end{array}<br>$$<br>针对线性系统, 假设成本向量  $\lambda$  和 $x$  之间, 满足:  $\quad \lambda&#x3D;P x$ .<br>对比最优路径上, 增量为 0 的结论:<br>$$<br>\begin{array}{l}<br>\begin{array}{ll}<br>L_{u}+\lambda^{T} f_{u}&#x3D;0 &amp; L_{x}&#x3D;x^{T} Q \<br>L_{u}&#x3D;u^{T} R<br>\end{array} \<br>L_{x}+\lambda^{T} f_{x}+\dot{\lambda}^{T}&#x3D;0 \quad f_{x}&#x3D;A \<br>\psi_{x}\left(x\left(t_{f}\right)\right)-\lambda^{T}\left(t_{f}\right)&#x3D;0 . \quad f_{u}&#x3D;B, \<br>\dot{x}&#x3D;A x+B u \<br>\text { 可以得到如下结果: } \<br>x\left(t_{o}\right)&#x3D;x_{o} \<br>\dot{\lambda}&#x3D;-Q x-A^{T} \lambda \<br>\lambda\left(t_{f}\right)&#x3D;0 \<br>R u+B^{T} \lambda&#x3D;0 . \<br>\end{array}<br>$$<br>针对线性系统, 假设成本向量  $\lambda$  和  $x$  之间, 满足:  $\quad \lambda&#x3D;P x$ .<br>系统的控制量等于:  $\quad R u+B^{T} \lambda&#x3D;0 . \quad \lambda&#x3D;P x$.<br>$$<br>u&#x3D;-R^{-1} B^{T} \lambda&#x3D;-R^{-1} B^{T} P x<br>$$<br>对于状态反馈控制器, 而言:<br>$$<br>u&#x3D;-K x<br>$$<br>对比上述两式, 可得:<br>$$<br>K&#x3D;R^{-1} B^{T} P<br>$$</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>初识obsidian——写markdown的好伙伴</title>
    <link href="/2022/11/23/obsidian-1/"/>
    <url>/2022/11/23/obsidian-1/</url>
    
    <content type="html"><![CDATA[<p>obsidian写markdown吊打vscode！我说的！(</p><span id="more"></span><p>其实也不尽然，很多博客相关的设置还是vscode好用（<br>但是obsidian有自己的长处。<br>obsidian是一款基于markdown语法的笔记软件，但是它也可以单纯的用作一款markdown编译器使用。 </p><p>优点其一：支持多端的编辑，ios，Android，mac，windows等都有客户端，随时随地都可以掏出设备进行编辑，但是官方多设备共享仓库需付费，可以用git等工具进行多端备份。</p><p>优点其二：支持预览基于mathjax的数学公式，工科生福音<br><del>（呃呃但是平常根本不想慢悠悠的写公式）</del><br>Markdown自己不具有渲染数学公式的能力，而公式在Obsidian中却可以显示成我们熟悉的样子，因为Obsidian自己内置了Mathjax显示引擎来渲染数学公式 （实测vscode有插件也可以做到）<br>这里放一个隔壁的beyes公式，在obsidian里面可以直接预览，非常方便  </p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">$$<br>P<span class="hljs-comment">(\omega_i|x)</span> = &#123;p<span class="hljs-comment">(x,\omega_i)</span> \over p<span class="hljs-comment">(x)</span>&#125; = &#123;p<span class="hljs-comment">(x|\omega_i)</span>P<span class="hljs-comment">(\omega_i)</span> \over p<span class="hljs-comment">(x)</span>&#125;, i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span><br>$$<br></code></pre></td></tr></table></figure><p>$$<br>P(\omega_i|x) &#x3D; {p(x,\omega_i) \over p(x)} &#x3D; {p(x|\omega_i)P(\omega_i) \over p(x)}, i&#x3D;1,2<br>$$</p><p>顺便备份下写的很好的两篇博客<br><a href="https://www.cnblogs.com/linxd/p/4955530.html">Mathjax与LaTex公式简介 - 林大勇 - 博客园 (cnblogs.com)</a><br><a href="https://blog.csdn.net/dabokele/article/details/79577072">Mathjax公式教程_dabokele的博客-CSDN博客_mathjax 公式</a><br>还有两个工具网站<br><a href="https://www.latexlive.com/">在线LaTeX公式编辑器-编辑器 (latexlive.com)</a><br><a href="https://latex.codecogs.com/legacy/eqneditor/editor.php?tdsourcetag=s_pctim_aiomsg">Online LaTeX Equation Editor - create, integrate and download (codecogs.com)</a>  </p><p>优点其三：超链接粘贴非常人性化，直接ctrlc+ctrlv就帮你规矩的写好格式了</p><p>优点其四：支持插件和思维导图，👴还没用，所以这里先不谈，留着后面来补全</p><p>现在的想法是先用obsidian写自己的日常学习积累，然后将一些成体系的东西用vscode修改一下丢到这里来。<br>大概就酱？<br>最后带个优秀的obsidianQA网站<br><a href="https://jackiexiao.github.io/obsidian-chinese-help/">Obsidian群分享 (jackiexiao.github.io)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>做着玩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拿到一个python项目怎么迅速上手跑通之速通配环境</title>
    <link href="/2022/10/29/pythonyizhi/"/>
    <url>/2022/10/29/pythonyizhi/</url>
    
    <content type="html"><![CDATA[<p>关键词：python pipreqs 虚拟环境</p><span id="more"></span><blockquote><p>*<strong>套盾</strong>：本人非计算机科班出身，如有问题，请多指正。</p></blockquote><blockquote><p>*<strong>NOTICE</strong>：<br>碎碎念，可以跳过<br>事情的起因是这样的，学长给了我一个做好的毕设：六轴机械臂，叫我自己先跑通。奈何给的文件中并未有详细的上手流程，我只能自己揣摩着完成。<br>项目的主要逻辑是这样的，机械臂由下位机工控板硬石-F4pro控制，并与上位机（电脑或手机）进行数据传输。<br>在完成了工控板的程序下载后，我开始琢磨上位机，上位机是一个python项目，且并没有封装成exe文件，于是我必须建立起相关的环境才能打开上位机。</p></blockquote><p>首先准备好anaconda作为环境管理工具，Pycharm作为编译器。</p><p>拿到一个python项目，首先需要确定它的主文件和支持文件，主文件一般是main.py。但是这个项目中有很多包需要安装，一个一个的安装不免繁琐。</p><p>于是这里就要请出我们的好帮手：<strong>pipreqs</strong></p><p>它可以自动帮我们寻找文件中调用的包，并合并成requirements.txt文件，并支持方便的一次性多个包环境配置。</p><p>首先先打开anaconda，新建一个环境，如six-axis。建立后打开该环境的terminal，输入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pipreqs  <span class="hljs-comment"># 安装pipreqs</span><br></code></pre></td></tr></table></figure><p>接着cd到项目文件夹，输入</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">pipreqs <span class="hljs-string">./</span>                                    <span class="hljs-comment">##Linux: </span><br>pipreqs <span class="hljs-string">./</span> <span class="hljs-params">--encoding=utf-8</span>       <span class="hljs-comment">##Windows: </span><br></code></pre></td></tr></table></figure><p>如果不出问题，你就能在项目文件夹里看到新建的requirements.txt文件。打开可以看到一系列的包和对应的版本号。</p><p>最后使用</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip3 <span class="hljs-keyword">install</span> -r requirements.txt<br></code></pre></td></tr></table></figure><p>就可以单命令完成多个包安装了。但是这个方法有个小问题，就是有些较为小众的包他可能没法检测，如我这个项目中的roboticstoolbox，我后续手动安装的，但是好在只有这个包没有检测到。</p><p>然后就是快乐的开跑了</p><p>打开pycharm，File&gt;-&gt;open文件夹打开项目。打开main.py，右键调出Modify Run Configuration，选中刚刚建立的环境，右键直接<strong>RUN</strong>！</p><p>一个注意点是全程的Terminal都是Anaconda打开的对应环境的Terminal，不要直接使用编译器内部的Terminal，会出现奇怪的报错。</p><p>基本就酱，结束！</p><blockquote><p>参考文献：<br>吸爱思DN  <a href="https://huifeng.blog.csdn.net/article/details/104176310?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-104176310-blog-113347780.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-104176310-blog-113347780.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=3">https://huifeng.blog.csdn.net/article/details/104176310?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-104176310-blog-113347780.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-104176310-blog-113347780.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=3</a><br>逼乎  <a href="https://zhuanlan.zhihu.com/p/345671388">https://zhuanlan.zhihu.com/p/345671388</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>技术碎片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>novelai：全新的纸片人老婆可能性！</title>
    <link href="/2022/10/12/novelaitest/"/>
    <url>/2022/10/12/novelaitest/</url>
    
    <content type="html"><![CDATA[<p>近日看到AI绘图上热搜了。</p><span id="more"></span><p>我就去了解了一下，嚯，好家伙，这不diffusion model吗，想当年我中学时期还玩过它一个著名的web部署模型，记得好像叫100-anime-waifu，包括我现在的B站头像都是它生成的（笑）</p><p><img src="/img/bhead.png" alt="B站头像捏"></p><p>原来的模型生成经常会出现一些不可名状的扭曲肉块，而且很多二刺螈美少女的脸、鼻子、眼睛、嘴巴都牛头不对马嘴，比如一个正向面对你的脸却长了一对斜视的眼睛，十分鬼畜。还有例如画风不统一和人物边界露出的情况发生。在这种情况下，生成的图片直接能用的情况非常少，需要大量的人力去筛选。</p><p>新模型试了一下，调试模型的过程只能说跌宕起伏，最后基于我自己的经历，在不基于现有图片生成时，新模型的水平大大提高了，尤其是对脸部和整体的把控，但是以图片为基础的生成下限还是很低，略有问题，我拿实验室队徽连续跑了N次都没有跑出一个美少女，但是校徽就跑出了不错的结果。（可能是队徽太过简约？）语义分割也有些问题，有些人像图片塞进去并没有得到对应位置的人像，更像是按原图色块进行的绘制。</p><p>新模型我觉得最主要的提升可能主要还是大量训练集素材的积累，听说novelai模型基于一个绘画网站的训练而来，大量素材的积累对这样一个模型肯定有显著的提升。</p><p>对于技术的争议我无意评价，此处不再赘述。</p><p>没啥说的，就附点训练图片吧。</p><hr><p>校徽系列<br><img src="/img/xiaohui.jpg" alt="校徽"><br><img src="/img/xiaohui1.png" alt="有点抽象"><br><img src="/img/xiaohui2.png" alt="最喜欢的一张"><br><img src="/img/xiaohui3.png" alt="加了大量集成咒文的一张"></p><blockquote><p>感谢B站用户 @秋葉aaaki 的集成炼丹炉  <a href="https://www.bilibili.com/video/BV1EV4y1L7dX/?share_source=copy_web&vd_source=b83e6476fa9783512b3ec91a34e02b96">丹炉来源</a><br>还有知乎用户 @然诺 的咒文详解  <a href="https://www.zhihu.com/question/558019952/answer/2710009035?utm_campaign=&utm_medium=social&utm_oi=752833622943219712&utm_psn=1563165958105165824&utm_source=qq">炼丹扩展阅读</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>做着玩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS学习（2）ROS通讯机制</title>
    <link href="/2022/10/08/ROStutorials2/"/>
    <url>/2022/10/08/ROStutorials2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于<br><a href="http://www.autolabor.com.cn/book/ROSTutorials/">http://www.autolabor.com.cn/book/ROSTutorials/</a><br>和配套视频<br><a href="https://www.bilibili.com/video/BV1Ci4y1L7ZZ/">https://www.bilibili.com/video/BV1Ci4y1L7ZZ/</a><br>教程进行学习，本文仅作个人学习时的补充学习记录。<br>如果您是想要从零开始学习ROS,请移步上述网址。<br>本文可作为第二章补充阅读。</p></blockquote><span id="more"></span><h1 id="内容大纲（摘自上述教程）"><a href="#内容大纲（摘自上述教程）" class="headerlink" title="内容大纲（摘自上述教程）"></a>内容大纲（摘自上述教程）</h1><h2 id="话题通信"><a href="#话题通信" class="headerlink" title="话题通信"></a>话题通信</h2><p>话题通信是ROS中使用频率最高的一种通信模式，话题通信是基于发布订阅模式的，也即:一个节点发布消息，另一个节点订阅该消息。</p><p>ROS Master 负责保管 Talker 和 Listener 注册的信息，并匹配话题相同的 Talker 与 Listener，帮助 Talker 与 Listener 建立连接，连接建立后，Talker 可以发布消息，且发布的消息会被 Listener 订阅。</p><p>话题通信适用于不断更新的数据传输相关的应用场景。</p><h2 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h2><p>ROS Master 负责保管 Server 和 Client 注册的信息，并匹配话题相同的 Server 与 Client ，帮助 Server 与 Client 建立连接，连接建立后，Client 发送请求信息，Server 返回响应信息。</p><h2 id="参数服务器"><a href="#参数服务器" class="headerlink" title="参数服务器"></a>参数服务器</h2><p>ROS Master 作为一个公共容器保存参数，Talker 可以向容器中设置参数，Listener 可以获取参数。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1>]]></content>
    
    
    
    <tags>
      
      <tag>ROS学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS学习（1）ROS概述与环境搭建笔记</title>
    <link href="/2022/10/07/ROStutorials1/"/>
    <url>/2022/10/07/ROStutorials1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于<br><a href="http://www.autolabor.com.cn/book/ROSTutorials/">http://www.autolabor.com.cn/book/ROSTutorials/</a><br>和配套视频<br><a href="https://www.bilibili.com/video/BV1Ci4y1L7ZZ/">https://www.bilibili.com/video/BV1Ci4y1L7ZZ/</a><br>教程进行学习，本文仅作个人学习时的补充学习记录。<br>如果您是想要从零开始学习ROS,请移步上述网址。<br>本文可作为第一章补充阅读。</p></blockquote><span id="more"></span><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h2><p>CMake是一个跨平台的编译(Build)工具,可以用简单的语句来描述所有平台的编译过程。</p><p>CMake能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。</p><p>CMake 不仅可以编译源代码、制作程序库、产生适配器（wrapper）、还可以用任意的顺序建构执行档。CMake 支持 in-place 建构（二进档和源代码在同一个目录树中）和 out-of-place 建构（二进档在别的目录里），因此可以很容易从同一个源代码目录树中建构出多个二进档。CMake 也支持静态与动态程式库的建构。<br><a href="https://blog.csdn.net/weixin_45525272/article/details/122053959">原文及衍生学习</a></p><h2 id="BASH"><a href="#BASH" class="headerlink" title="BASH"></a>BASH</h2><p>Bash，Unix shell的一种，在1987年由布莱恩·福克斯为了GNU计划而编写。1989年发布第一个正式版本，原先是计划用在GNU操作系统上，但能运行于大多数类Unix系统的操作系统之上，包括Linux与Mac OS X v10.4都将它作为默认shell。</p><p>Bash是Bourne shell的后继兼容版本与开放源代码版本，它的名称来自Bourne shell（sh）的一个双关语（Bourne again &#x2F; born again）：Bourne-Again SHell。</p><p>Bash是一个命令处理器，通常运行于文本窗口中，并能执行用户直接输入的命令。Bash还能从文件中读取命令，这样的文件称为脚本。和其他Unix shell 一样，它支持文件名替换（通配符匹配）、管道、here文档、命令替换、变量，以及条件判断和循环遍历的结构控制语句。包括关键字、语法在内的基本特性全部是从sh借鉴过来的。其他特性，例如历史命令，是从csh和ksh借鉴而来。总的来说，Bash虽然是一个满足POSIX规范的shell，但有很多扩展。  </p><h3 id="Unix-shell"><a href="#Unix-shell" class="headerlink" title="Unix shell"></a>Unix shell</h3><p>Unix shell，通常被称作“命令行”，为Unix和类Unix操作系统提供了传统的用户界面。用户通过输入shell所执行的命令，引导计算机的操作。在微软Windows操作系统平台，类似程序是command.com，或者基于Windows NT内核操作系统的cmd.exe。</p><h2 id="src文件夹"><a href="#src文件夹" class="headerlink" title="src文件夹"></a>src文件夹</h2><p>src 在软件中都是指 source ，也就是 源代码 的意思。 在很多语言的工程里都一个src文件夹 用来存放源代码以区别开其它文件 （模板文件、Web文件等）。 </p><h2 id="xml文件"><a href="#xml文件" class="headerlink" title=".xml文件"></a>.xml文件</h2><p>XML (Extensible Markup Language) 是一种类似于 HTML 的标记语言，但是 XML 没有使用预定义的标记。 因此，您可以根据自己的设计需求定义专属于您的标记。 这是一种十分有用的可存储、可搜索和可共享的格式存储数据的方法。<br>.launch文件也属于.xml文件，ROS中用.launch文件来同时启动多个节点。<br><a href="https://www.runoob.com/xml/xml-intro.html">衍生学习</a></p><h2 id="json"><a href="#json" class="headerlink" title=".json"></a>.json</h2><p>JSON: JavaScript Object Notation(JavaScript 对象表示法)<br>JSON 是存储和交换文本信息的语法，类似 XML。<br>JSON 比 XML 更小、更快，更易解析，  JSON 易于人阅读和编写。<br>C、Python、C++、Java、PHP、Go等编程语言都支持 JSON。<br>在VScode里用作配置文件。<br><a href="http://c.biancheng.net/json/">衍生学习</a></p><h1 id="一点有意义的快捷键（in-VScode）"><a href="#一点有意义的快捷键（in-VScode）" class="headerlink" title="一点有意义的快捷键（in VScode）"></a>一点有意义的快捷键（in VScode）</h1><p><strong>ctrl+&#x2F;</strong><br>注释和反注释</p><p><strong>ctrl+shift+b</strong><br>编译</p><p><strong>ctrl+shift+p</strong><br>调出用于执行命令的输入框，这些命令来自VSCode自带已经插件扩展的命令。插件扩展命令可以查看以下示例，在package.json里注册命令，然后通过注册命令找到对应代码执行相应逻辑。</p><p><strong>ctrl+&#96;</strong><br>打开终端</p>]]></content>
    
    
    
    <tags>
      
      <tag>ROS学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>守望先锋，再见。</title>
    <link href="/2022/10/05/overwatch-return/"/>
    <url>/2022/10/05/overwatch-return/</url>
    
    <content type="html"><![CDATA[<p>如果要选一款我游戏中的白月光，毫无意外，就是守望先锋了。</p><span id="more"></span><p>和暴雪的不解之缘最开始出现在五年级的那个圣诞节晚上，我的父亲用他14英寸的老戴尔带着我打了我人生中第一把星际争霸。</p><p>虫族，速本爆狗一波流。</p><p>我难以想象在1998年就有人做出这样一款游戏性和世界观都无可挑剔的作品。靠着一本牛津英汉词典。我硬生生的打通了星际1的剧情模式。最后一幕CG放完的那个下午，我的人生目标就确立了：  </p><p>去暴雪，做出很COOL的游戏。</p><p>上了初中的我接触到了战网，续上了科普鲁星区的故事；开始了艾泽拉斯的冒险；结识了时空枢纽的英雄；交上了符文之地的朋友。耳闻暴雪在做一款名为TITAN的旷世MMORPG巨作，虽然其最后难产变成了一款射击游戏，但我也翘首以盼。</p><p>328元。那时候我没有银行卡没有支付宝，一张点卡30块，我买了11张。</p><p>拿着那一沓卡片走回家，我觉得我是这个世界上最幸福的小孩。</p><p>2016年，我14岁。近未来的故事背景，各具特色的角色设计，还有一堆待发掘的彩蛋和对英雄的致意。机械忍者，时空回溯，能变成重机枪的机器人，靠着音乐战斗的DJ，穿着合金重铠拿着喷射巨锤的圣骑士，掌握起死回生之力的战场女武神。每个中午，我都会骑上我的小单车，风驰电掣地飞回家中，用U盘里准备好的程序干开那台WINDOWS7的密码，徜徉在那个世界里。</p><p>但是，我长大了，它没有。</p><p>不知什么时候，暴雪死了。先是商业化赛事失败，然后是风暴英雄停更，然后是星际，然后是“你们没有手机吗？”，然后是原版没啥区别的魔兽Ⅲ重置和父马可亲的汉化······我都记不清先后了，我也从一个只玩暴雪游戏的暴白变成了恨不得暴雪早点死的暴黑。</p><p>你问守望？守望一直是那样，除了一点无足轻重的平衡性改动外，开发组就像死了一样销声匿迹。</p><p>都这样了，体面点吧。</p><p>我本来不想给暴雪这个机会了。</p><p>但我说不上来。</p><p>守望先锋关服了。</p><p>我的青春结束了。</p><p>或者说，它早就结束了，只是需要一个体面的葬礼。</p><p>至于守望二，我已经不是14岁了，暴雪也不是那个暴雪了。</p><p>但是我愿意给他这个机会。</p><p>这个世界需要英雄。</p>]]></content>
    
    
    
    <tags>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重走大一路：STM32的入门笔记(1)</title>
    <link href="/2022/10/04/STM32-1/"/>
    <url>/2022/10/04/STM32-1/</url>
    
    <content type="html"><![CDATA[<p>STM32作为现今最常用的机器人主控MPU非常重要，很有必要好好学习。第一章笔记，将给出它的概述。</p><span id="more"></span><p>我将解答部分我之前不太明白的部分问题和术语，希望对看这篇文章的你也有些帮助。</p><h1 id="1-初识STM32"><a href="#1-初识STM32" class="headerlink" title="1.初识STM32"></a>1.初识STM32</h1><blockquote><p>STM32系列是专为要求高性能、低成本、低功耗的嵌入式应用设计的ARM Cortex®-M0，M0+，M3, M4和M7内核 （ST’s product portfolio contains a comprehensive range of microcontrollers, from robust, low-cost 8-bit MCUs up to 32-bit ARM-based Cortex®-M0 and M0+, Cortex®-M3,Cortex®-M4 Flash microcontrollers with a great choice of peripherals. ST has also extended this range to include an ultra-low-power MCU platform)。<br>按内核架构分为不同产品：主流产品（STM32F0、STM32F1、STM32F3）、超低功耗产品（STM32L0、STM32L1、STM32L4、STM32L4+）、高性能产品（STM32F2、STM32F4、STM32F7、STM32H7<br>（来自百度百科）</p></blockquote><p>用人话讲，STM32是一款32位的单片机MCU(Micro Control Unit)，适用于许多开发环境。它就是整个机器人的大脑，负责主控。它通过控制引脚上的高低电平来控制外部执行器。<br>它的内核基于<strong>ARM® Cortex®-M</strong>（一种ARM公司的处理器架构设计）。<a href="https://blog.csdn.net/erinblog/article/details/78156032">衍生阅读</a></p><p>想使用STM32首先我们要会<a href="https://www.dotcpp.com/"><strong>C语言</strong></a>。还要有基本的<strong>模电数电知识</strong>。若有<strong>计算机组成原理</strong>的基础更好，但不会也不影响基本的使用。</p><h1 id="2-命名规则"><a href="#2-命名规则" class="headerlink" title="2.命名规则"></a>2.命名规则</h1><p><img src="/img/stmxiangjie.png"></p><h1 id="3-术语解释"><a href="#3-术语解释" class="headerlink" title="3.术语解释"></a>3.术语解释</h1><h2 id="开发板"><a href="#开发板" class="headerlink" title="开发板"></a>开发板</h2><p>开发板是一些企业或组织为了方便不懂硬件设计的群体设计的含主控芯片的电路板，上面有各种元器件和接口，方便这些群体直接通过开发板进行对主控的编程和对执行器的控制。</p><h2 id="上位机和下位机"><a href="#上位机和下位机" class="headerlink" title="上位机和下位机"></a>上位机和下位机</h2><blockquote><p>上位机是指可以直接发出操控命令的计算机，一般是PC&#x2F;host computer&#x2F;master computer&#x2F;upper computer,屏幕上显示各种信号变化（液压，水位，温度等）。下位机是直接控制设备获取设备状况的计算机，一般是PLC&#x2F;单片机single chip microcomputer&#x2F;slave computer&#x2F;lower computer之类的。上位机发出的命令首先给下位机，下位机再根据此命令解释成相应时序信号直接控制相应设备。下位机不时读取设备状态数据（一般为模拟量），转换成数字信号反馈给上位机。简言之如此，实际情况千差万别，但万变不离其宗：上下位机都需要编程，都有专门的开发系统。<br>在概念上，控制者和提供服务者是上位机，被控制者和被服务者是下位机，也可以理解为主机和从机的关系，但上位机和下位机是可以转换的。<br><a href="https://zhuanlan.zhihu.com/p/77587097#:~:text=%E4%B8%8A%E4%BD%8D%E6%9C%BA%E6%98%AF%E6%8C%87%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%8F%91%E5%87%BA%E6%93%8D%E6%8E%A7%E5%91%BD%E4%BB%A4%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%8C%E4%B8%80%E8%88%AC%E6%98%AFPC%2Fhost%20computer%2Fmaster%20computer%2Fupper%20computer%2C%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%90%84%E7%A7%8D%E4%BF%A1%E5%8F%B7%E5%8F%98%E5%8C%96%EF%BC%88%E6%B6%B2%E5%8E%8B%EF%BC%8C%E6%B0%B4%E4%BD%8D%EF%BC%8C%E6%B8%A9%E5%BA%A6%E7%AD%89%EF%BC%89%E3%80%82,%E4%B8%8B%E4%BD%8D%E6%9C%BA%E6%98%AF%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E8%AE%BE%E5%A4%87%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E7%8A%B6%E5%86%B5%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%8C%E4%B8%80%E8%88%AC%E6%98%AFPLC%2F%E5%8D%95%E7%89%87%E6%9C%BAsingle%20chip%20microcomputer%2Fslave%20computer%2Flower%20computer%E4%B9%8B%E7%B1%BB%E7%9A%84%E3%80%82">引用来源</a></p></blockquote><h2 id="HAL库，标准库和直接配置寄存器"><a href="#HAL库，标准库和直接配置寄存器" class="headerlink" title="HAL库，标准库和直接配置寄存器"></a>HAL库，标准库和直接配置寄存器</h2><p>STM32的开发商ST（意法半导体）官方有封装好的<a href="https://cloud.tencent.com/developer/article/1861948"><strong>HAL库</strong></a>（ST官方推荐的库），<strong>标准固件库</strong>（旧版本库，现已不再更新）可用于STM32的编程，同样你也可以使用<strong>寄存器编程</strong>（较繁琐）。现在大部分情况都使用HAL库。</p><blockquote><p>1、直接配置寄存器<br>不少先学了51的朋友可能会知道，会有一小部分人或是教程是通过汇编语言直接操作寄存器实现功能的，这种方法到了STM32就变得不太容易行得通了，因为STM32的寄存器数量是51单片机的十数倍，如此多的寄存器根本无法全部记忆，开发时需要经常的翻查芯片的数据手册，此时直接操作寄存器就变得非常的费力了。但还是会有很小一部分人，喜欢去直接操作寄存器，因为这样更接近原理，知其然也知其所以然。<br>2、标准库<br>上面也提到了，STM32有非常多的寄存器，而导致了开发困难，所以为此ST公司就为每款芯片都编写了一份库文件，也就是工程文件里stm32F1xx…之类的。在这些 .c .h文件中，包括一些常用量的宏定义，把一些外设也通过结构体变量封装起来，如GPIO口时钟等。所以我们只需要配置结构体变量成员就可以修改外设的配置寄存器，从而选择不同的功能。也是目前最多人使用的方式，也是学习STM32接触最多的一种开发方式，我也就不多阐述了。<br>3、HAL库<br>HAL库是ST公司目前主力推的开发方式，全称就是Hardware Abstraction Layer（抽象印象层）。库如其名，很抽象，一眼看上去不太容易知道他的作用是什么。<br>它的出现比标准库要晚，但其实和标准库一样，都是为了节省程序开发的时期，而且HAL库尤其的有效，如果说标准库把实现功能需要配置的寄存器集成了，那么HAL库的一些函数甚至可以做到某些特定功能的集成。也就是说，同样的功能，标准库可能要用几句话，HAL库只需用一句话就够了。<br>并且HAL库也很好的解决了程序移植的问题，不同型号的stm32芯片它的标准库是不一样的，例如在F4上开发的程序移植到F3上是不能通用的，而使用HAL库，只要使用的是相通的外设，程序基本可以完全复制粘贴，注意是相通外设，意思也就是不能无中生有，例如F7比F3要多几个定时器，不能明明没有这个定时器却非要配置，但其实这种情况不多，绝大多数都可以直接复制粘贴。是而且使用ST公司研发的STMcube软件，可以通过图形化的配置功能，直接生成整个使用HAL库的工程文件，可以说是方便至极，但是方便的同时也造成了它执行效率的低下，在各种论坛帖子真的是被吐槽的数不胜数。</p></blockquote><p><a href="https://cloud.tencent.com/developer/article/1861948">引用来源及扩展阅读</a></p><h2 id="8位，32位和64位"><a href="#8位，32位和64位" class="headerlink" title="8位，32位和64位"></a>8位，32位和64位</h2><p>32位和64位操作系统是指，CPU一次处理数据的能力是32位还是64位。  所谓32位，就是CPU一次只能处理32位，也就是4个字节的数据；而64位，CPU一次就能处理64位，即8个字节的数据。<br>51单片机大部分为8位，而STM32的位数为32位。</p><h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><blockquote><p>Jlink支持所有ARM芯片的仿真调试，而STlink仅仅支持ST公司的相关芯片。<br><a href="https://blog.csdn.net/ReCclay/article/details/79156325">引用来源及扩展阅读</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>audio | 航站楼第一次的audio</title>
    <link href="/2022/10/02/first_audio/"/>
    <url>/2022/10/02/first_audio/</url>
    
    <content type="html"><![CDATA[<p>做技术的人的自我修养应该是怎么样的？我觉得大家心里都有自己的答案。</p><span id="more"></span><p>以我之鄙见，最重要的一点应该是热爱技术，其次应该是持续而稳定的热情输出，最后则是一点灵感和机遇。</p>]]></content>
    
    
    
    <tags>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
