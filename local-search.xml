<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器人学大作业</title>
    <link href="/2023/03/15/robotics_homework/"/>
    <url>/2023/03/15/robotics_homework/</url>
    
    <content type="html"><![CDATA[<p>本文旨在记录HIT机器人学课程相关作业  </p><span id="more"></span><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>R-水平转动关节，<br>R1-垂直转动关节，<br>P-水平移动关节，<br>P1-垂直移动关节，</p><p>图示R1RR三关节机械臂，已知：结构参数为L1、L2、L3，连杆1、2、3的质量分别为m1、m2、m3，三连杆质量均集中连杆末端关节上。</p><p>我的作业是PPP1<br>即前两关节水平移动第三关节垂直移动</p><p>(1)试建立该机械臂坐标系并列写连接变量表。（10分）<br>(2)试推导机械臂末端连杆相对基座坐标系的齐次坐标变换矩阵。（10分）<br>(3)已知末端连杆位姿，推导该机械臂运动学逆解方程。（10分）<br>(4)已知各关节广义速度，试推导各连杆及质心在自身坐标系中描述的相对基系的广义速度计算方程。（10分）<br>(5)已知各关节广义加速度和重力加速度，试推导各连杆及质心的广义加速度计算方程。（10分）<br>(6)机械臂空载，推导各关节电机驱动力或力矩计算方程。（10分）</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术碎片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人控制理论课设知识意识流综合</title>
    <link href="/2023/01/03/robotic_control_advance/"/>
    <url>/2023/01/03/robotic_control_advance/</url>
    
    <content type="html"><![CDATA[<p>本文是为完成课设自学的意识流博客，主要供自己记录。如果有交流指正敬请不吝赐教。</p><span id="more"></span><h2 id="一阶惯性环节转换为数字滤波器推导"><a href="#一阶惯性环节转换为数字滤波器推导" class="headerlink" title="一阶惯性环节转换为数字滤波器推导"></a>一阶惯性环节转换为数字滤波器推导</h2><blockquote><p>前置知识：<br>课程：自动控制理论和信号处理基础（信号与系统）<br>知识点：了解Z变换，拉普拉斯变换和一阶惯性环节</p></blockquote><p>一阶惯性环节本身就是低通滤波器，可将一阶惯性环节改为  $$\Phi(s)&#x3D;\frac{U_{o}(s)}{U_{i}(s)}&#x3D;\frac{1}{RCs+1}&#x3D;\frac{\omega_{c}}{s+\omega_{c}} $$ ，其中  $\omega_{c}&#x3D;\frac{1}{RC}$  为截止频率。为了便于在C语言中实现一阶低通滤波，将其离散化，使用一阶向后差分  $s&#x3D;\frac{1-z^{-1}}{T_{s}}$  ，可得</p><p>$$\begin{array}{l}<br>\phi(z)&#x3D;\frac{Y(z)}{X(z)}&#x3D;\frac{\omega_{c}}{\frac{1-Z^{-1}}{T_{s}}+\omega_{c}}&#x3D;\frac{T_{s} \omega_{c}}{\left(1-Z^{-1}\right)+T_{s} \omega_{c}} \<br>Y(z)\left(\left(1-Z^{-1}\right)+T_{s} \omega_{c}\right)&#x3D;X(z) T_{s} \omega_{c} \<br>Y(n)-Y(n-1)+Y(n) T_{s} \omega_{c}&#x3D;X(n) T_{s} \omega_{c} \<br>Y(n)&#x3D;\frac{1}{\left(1+T_{s} \omega_{c}\right)} Y(n-1)+\frac{T_{s} \omega_{c}}{\left(1+T_{s} \omega_{c}\right)} X(n) \<br>Y(n)&#x3D;Y(n-1)-\frac{T_{s} \omega_{c}}{\left(1+T_{s} \omega_{c}\right)} Y(n-1)+\frac{T_{s} \omega_{c}}{\left(1+T_{s} \omega_{c}\right)} X(n) \<br>Y(n)&#x3D;Y(n-1)+\frac{T_{s} \omega_{c}}{\left(1+T_{s} \omega_{c}\right)}(X(n)-Y(n-1))<br>\end{array}$$</p><p>化简成这样后，低通滤波就可以使用两个加减法和一个乘法实现，写成C语言形式，可以化为</p><p>$$Y(n)+&#x3D;\frac{\omega_{c}}{\left(f_{s}+\omega_{c}\right)}(X(n)-Y(n-1))$$<br>这里可以给出结论，同样的具有一定频率的信号输入(低通滤波器对直流量无效)，$\frac{Ts\omega c}{1+Ts\omega c}$越大，说明这个低通滤波器的截止频率越大，滤波效果降低；反之，滤波效果增强，但随之而来的是信号的失真程度增大，各有利弊，需要根据不同的应用需求确定该滤波系数的大小。</p><h2 id="机器人交互控制"><a href="#机器人交互控制" class="headerlink" title="机器人交互控制"></a>机器人交互控制</h2><p>1.直接力控 Direct force control</p><p>2.间接力控 Indirect force control<br>2.1柔顺控制 Compliance control<br>2.1.1被动柔顺 Passive compliance<br>2.1.2主动柔顺 Active compliance</p><h3 id="2-2阻抗-x2F-导纳控制-Admittance-x2F-Impedance-control"><a href="#2-2阻抗-x2F-导纳控制-Admittance-x2F-Impedance-control" class="headerlink" title="2.2阻抗&#x2F;导纳控制 Admittance&#x2F;Impedance control"></a>2.2阻抗&#x2F;导纳控制 Admittance&#x2F;Impedance control</h3><blockquote><p>参考资料：<br><a href="https://zhuanlan.zhihu.com/p/126338809">阻抗&#x2F;导纳控制最强解析 - 知乎 (zhihu.com)</a><br><a href="https://www.aiimooc.com/mall/preshow-htm-itemid-660.html">机器人阻抗控制及其在人机协作中的应用_睿慕课 (aiimooc.com)</a><br><a href="https://www.zhihu.com/question/43633361/answer/124417009">阻抗控制的实现方式应该是多种多样的，请能否概述一下大概有几种方式以及主流的方法？-知乎 </a></p></blockquote><p>考虑到力的影响，光使用位置控制来控制机器人的关节必然会出现误差，引起环境或机器人的损坏。此时我们就要引入<strong>柔顺</strong>，即类似弹簧一样的力与位置间关系，来防止控制器无上限的输出力矩。</p><p>但是机器人不能总是有弹簧相助，而且弹簧的刚度不能按需调节，也很难做到各向异性（在不同方向上有不同的刚度）。所以希望能用控制算法让机器臂表现出想要的柔性。也就是实际上是由控制算法实现的弹性系统。最简单的有弹性、而且不会永久震荡的系统就是<em><strong>Mass-Spring-Damper（质量-弹簧-阻尼系统）</strong></em>。</p><p>动力学方程即$$M \ddot{x}+b \dot{x}+k x&#x3D;F+F_{e x t}$$<br>其中<br>$M：质量，b：阻尼参数，k：弹性系数，x:位移，F：系统恒力，F_{e x t}：突加外力$<br>阻抗控制&#x2F;导纳控制的核心思想就是使用一个控制器来模拟这样一个有弹性的系统。</p><ol><li><p>测量当前位置和目标位置的差，调整末端产生的力（一般通过调整各关节力矩实现）。这种通常称为导纳控制或刚度控制。</p></li><li><p>测量末端受到的力，调整末端的速度。这种常称为阻抗控制。</p></li></ol><h4 id="2-2-1关节空间-Joint-space"><a href="#2-2-1关节空间-Joint-space" class="headerlink" title="2.2.1关节空间 Joint space"></a>2.2.1关节空间 Joint space</h4><p> 目标 : 让机器人的每一个关节都体现出由弹簧-阻尼-质量组成的二阶系统的动态特性。</p><p>$$\boldsymbol{M}<em>{d} \ddot{\tilde{\boldsymbol{q}}}+\boldsymbol{D}</em>{d} \dot{\tilde{\boldsymbol{q}}}+\boldsymbol{K}<em>{d} \tilde{\boldsymbol{q}}&#x3D;\boldsymbol{\tau}</em>{e x t}, \quad \tilde{\boldsymbol{q}}&#x3D;\boldsymbol{q}_{d}-\boldsymbol{q}<br>$$</p><ul><li>机器人动力学方程:</li></ul><p>$$\boldsymbol{M}(\boldsymbol{q}) \ddot{q}+\boldsymbol{C}(\dot{\boldsymbol{q}}, \boldsymbol{q}) \dot{\boldsymbol{q}}+\boldsymbol{g}<em>{\boldsymbol{k}}(\boldsymbol{q})&#x3D;\boldsymbol{\tau}-\boldsymbol{\tau}</em>{\text {ext }}<br>$$<br>其中$q:关节位置，\dot{\boldsymbol{q}}：关节角速度，\ddot{\boldsymbol{q}}：关节角加速度，M(q)：关节惯性矩阵，C(\dot{\boldsymbol{q}},q)：关节科里奥利矩阵，g_k(q)：重力矩阵$</p><ul><li>假定机器人的控制任务是跟随一条提前规划的轨迹， 即：  $$\ddot{\boldsymbol{q}}<em>{d}, \dot{\boldsymbol{q}}</em>{d}, \boldsymbol{q}_{d} $$</li><li>则可定义如下的关节转矩控制输入:<br>$$<br>\begin{aligned}<br>\boldsymbol{\tau}&#x3D; &amp; \boldsymbol{M}(\boldsymbol{q}) \ddot{\boldsymbol{q}}<em>{d}+\boldsymbol{C}(\dot{\boldsymbol{q}}, \boldsymbol{q}) \dot{\boldsymbol{q}}+\boldsymbol{g}(\boldsymbol{q}) \<br>&amp; +\boldsymbol{M}(\boldsymbol{q}) \boldsymbol{M}</em>{d}^{-1}\left(\boldsymbol{D}<em>{d} \dot{\tilde{\boldsymbol{q}}}+\boldsymbol{K}</em>{d} \tilde{\boldsymbol{q}}\right)+\left(\boldsymbol{I}-\boldsymbol{M}(\boldsymbol{q}) \boldsymbol{M}<em>{d}^{-1}\right) \boldsymbol{\tau}</em>{e x t}<br>\end{aligned}<br>$$</li><li>将上式代回机器人动力学方程，消去相同项，等式两边分别乘以  $M^{-1}(\boldsymbol{q}), M_{d}$  整理后可得到所期望的二阶系统动态方程。</li></ul><h4 id="2-2-2笛卡尔空间-Cartesian-space"><a href="#2-2-2笛卡尔空间-Cartesian-space" class="headerlink" title="2.2.2笛卡尔空间 Cartesian space"></a>2.2.2笛卡尔空间 Cartesian space</h4><h4 id="2-2-3-例子"><a href="#2-2-3-例子" class="headerlink" title="2.2.3 例子"></a>2.2.3 例子</h4><blockquote><p>参考哈尔滨工业大学邢宏军硕士学位论文《基于主被动柔顺的机器人旋拧阀门作业研究》</p></blockquote><p>机器人与环境间的接触力与机器人位移的动态关系设为为质量-弹簧-阻尼系统, 即:</p><p>$$\boldsymbol{F}<em>{e}&#x3D;\boldsymbol{M}</em>{e}\left(\ddot{\boldsymbol{X}}-\ddot{\boldsymbol{X}}<em>{e}\right)+\boldsymbol{B}</em>{e}\left(\dot{\boldsymbol{X}}-\dot{\boldsymbol{X}}<em>{e}\right)+\boldsymbol{K}</em>{e}\left(\boldsymbol{X}-\boldsymbol{X}_{e}\right)$$</p><p>式中:  $\boldsymbol{S}<em>{e}&#x3D;\left{\boldsymbol{X}</em>{e}(t), \dot{\boldsymbol{X}}<em>{e}(t), \ddot{\boldsymbol{X}}</em>{e}(t)\right}$  一一环境位置变化轨迹;<br> $\boldsymbol{M}<em>{e}, \boldsymbol{B}</em>{e}, \boldsymbol{K}_{e}$  一一分别表示环境惯性、阻尼和刚度矩阵。</p><p>由于在旋拧阀门过程中, 机器人的关节运动缓慢, 因此, 可以忽略机器人末端运动速度  $\dot{\boldsymbol{X}}$  和加速度  $\ddot{\boldsymbol{X}}$ 。同时, 尽管在旋拧过程中, 阀门手轮的位置(环境位置)一直处于移动状态, 但移动缓慢, 可忽略环境位移的速度  $\dot{\boldsymbol{X}}<em>{e}$ 和加速度  $\ddot{\boldsymbol{X}}</em>{e}$  影响。</p><p>综上, 本文在分析过程中, 将机器人末端与环境间的接触模型简化为:</p><p>$$\boldsymbol{F}<em>{e}&#x3D;\left{\begin{array}{ll}<br>\boldsymbol{K}</em>{e}\left(\boldsymbol{X}-\boldsymbol{X}<em>{e}\right) &amp; \boldsymbol{X} \geq \boldsymbol{X}</em>{e} \<br>0 &amp; \boldsymbol{X}&lt;\boldsymbol{X}_{e}<br>\end{array}\right.$$</p><h4 id="2-2-4-自适应阻抗控制"><a href="#2-2-4-自适应阻抗控制" class="headerlink" title="2.2.4 自适应阻抗控制"></a>2.2.4 自适应阻抗控制</h4><h4 id="2-2-5-例子"><a href="#2-2-5-例子" class="headerlink" title="2.2.5 例子"></a>2.2.5 例子</h4><p>在实际旋拧阀门过程中, 无法实时获得阀门手轮的实际环境位置  $x_{e}(t)$ , 由此 导致无法准确设定机器人控制的参考位置 $x_{r}(t)$ , 从而使设计系统存在跟踪误差。本部分利用自适应控制实时计算参考位置  $x_{r}(t)$  以实现对期望作用力  $f_{d}$  的跟踪。自适应控制中设计的机器人参考位置偏移量是力跟踪误差  e  的函数, 如式(4-21)所示。</p><p>$$x_{r}(t)&#x3D;g(t)+k_{p}(t) e(t)+k_{d}(t) \dot{e}(t)$$</p><p>式中,  $k_{p}(t)$  和  $k_{d}(t)$  分别是作用在力误差上的自适应比例和微分反馈增益,  $g(t)$是自适应控制方法产生的辅助位置信号。由式(4-10)可知, 当期望力恒定时, 力误差动力学模型可简化为:</p><p>$$m \ddot{e}+b \dot{e}+\left(k+k_{e}\right) e&#x3D;k f_{d}+m k_{e} \ddot{x}<em>{e}+b k</em>{e} \dot{x}<em>{e}+k k</em>{e} x_{e}-k k_{e} x_{r}<br>$$<br>将式(4-21)代入式(4-22)中, 可得:</p><p>$$\ddot{e}+\frac{b+k k_{e} k_{d}(t)}{m} \dot{e}+\frac{k+k_{e}+k k_{e} k_{p}(t)}{m} e&#x3D;\frac{k\left(f_{d}+k_{e} x_{e}\right)+m k_{e} \ddot{x}<em>{e}+b k</em>{e} \dot{x}<em>{e}-k k</em>{e} g(t)}{m}$$</p><p>式(4-23)表示的即是 MRAC 系统中的可调被控对象。为便于分析, 将式(4-23) 简化为:</p><p>$$\ddot{e}(t)+a(t) \dot{e}(t)+b(t) e(t)&#x3D;f(t)$$</p><p>式中:</p><p>$$\begin{array}{l}<br>a(t)&#x3D;\left[b+k k_{e} k_{d}(t)\right] &#x2F; m \<br>b(t)&#x3D;\left[k+k_{e}+k k_{e} k_{p}(t)\right] &#x2F; m \<br>f(t)&#x3D;\left[k\left(f_{d}+k_{e} x_{e}\right)+m k_{e} \ddot{x}<em>{e}+b k</em>{e} \dot{x}<em>{e}-k k</em>{e} g(t)\right] &#x2F; m<br>\end{array}<br>$$<br>假定力跟踪误差的理想动态模型为:<br>$$<br>\ddot{e}<em>{m}(t)+2 \zeta \omega \dot{e}</em>{m}(t)+\omega^{2} e_{m}(t)&#x3D;0<br>$$<br>式中, $\zeta, \omega$  分别为用户自定义的阻尼比和无阻尼自然频率。<br>由式(4-24)和式(4-25) 可知:<br>$$<br>\left(\ddot{e}-\ddot{e}<em>{\mathrm{m}}\right)+2 \zeta \omega\left(\dot{e}-\dot{e}</em>{m}\right)+\omega^{2}\left(e-e_{m}\right)&#x3D;f+(2 \zeta \omega-a) \dot{e}+\left(\omega^{2}-b\right) e<br>$$<br>式(4-26)的状态空间形式为:<br>$$<br>\dot{E}&#x3D;\left[\begin{array}{cc}0 &amp; 1 \-\omega^{2} &amp; -2 \zeta \omega<br>\end{array}\right] E+\left[\begin{array}{cc}0 &amp; 0 \\omega^{2}-b &amp; 2 \zeta \omega-a<br>\end{array}\right]\left[\begin{array}{l}e \\dot{e} \end{array}\right]+\left[\begin{array}{l}0 \f<br>\end{array}\right]<br>$$<br>式中,  $E&#x3D;\left[\left(e-e_{m}\right),\left(\dot{e}-\dot{e}_{m}\right)\right]^{\mathrm{T}}$  是  $2 \times 1$  阶跟踪误差向量。构造正标量 Lyapunov 候补函数 V  :</p><p>$$V&#x3D;E^{T} P E+Q_{0}\left(f-f^{<em>}\right)^{2}+Q_{1}\left(\omega^{2}-b+b^{</em>}\right)^{2}+Q_{2}\left(2 \zeta \omega-a+a^{<em>}\right)^{2}<br>$$<br>式中,  $\left[f^{</em>}, b^{<em>}, a^{</em>}\right]$  是待定义时间函数, $\left[Q_{0}, Q_{1}, Q_{2}\right]$  是正标量,  $P&#x3D;\left[\begin{array}{ll}p_{1} &amp; p_{2} \ p_{2} &amp; p_{3}\end{array}\right]$  是  $2 \times 2$ 阶正定对称矩阵且满足 Lyapunov 方程, 即:</p><p>$$\left[\begin{array}{ll}<br>p_{1} &amp; p_{2} \<br>p_{2} &amp; p_{3}<br>\end{array}\right]\left[\begin{array}{cc}<br>0 &amp; 1 \<br>-\omega^{2} &amp; -2 \zeta \omega<br>\end{array}\right]+\left[\begin{array}{cc}<br>0 &amp; -\omega^{2} \<br>1 &amp; -2 \zeta \omega<br>\end{array}\right]\left[\begin{array}{ll}<br>p_{1} &amp; p_{2} \<br>p_{2} &amp; p_{3}<br>\end{array}\right]&#x3D;-\left[\begin{array}{ll}<br>q_{1} &amp; q_{2} \<br>q_{2} &amp; q_{3}<br>\end{array}\right]<br>$$<br>其中,  $Q&#x3D;\left[\begin{array}{ll}q_{1} &amp; q_{2} \ q_{2} &amp; q_{3}\end{array}\right]$  是正定对称矩阵。则 Lyapunov 候补函数  V  的导数为:<br>$$<br>\begin{aligned}<br>\dot{V}&#x3D; &amp; -E^{T} Q E+\left[2 Q_{0} f\left(\dot{f}-\dot{f}^{<em>}\right)+2 q f-2 Q_{0} f^{</em>}\left(\dot{f}-\dot{f}^{<em>}\right)\right]+ \<br>&amp; {\left[2 Q_{1}\left(b-\omega^{2}\right)\left(\dot{b}-\dot{b}^{</em>}\right)-2 q\left(b-\omega^{2}\right) e-2 Q_{1} b^{<em>}\left(\dot{b}-\dot{b}^{</em>}\right)\right]+} \<br>&amp; {\left[2 Q_{2}(a-2 \zeta \omega)\left(\dot{a}-\dot{a}^{<em>}\right)-2 q(a-2 \zeta \omega) \dot{e}-2 Q_{2} a^{</em>}\left(\dot{a}-\dot{a}^{<em>}\right)\right] }<br>\end{aligned}<br>$$<br>其中,  $q&#x3D;p_{2} e+p_{3} \dot{e}$  。为保证式(4-29)的渐进稳定性, 设定:<br>$$<br>\begin{array}{l}<br>2 Q_{0} f\left(\dot{f}-\dot{f}^{</em>}\right)+2 q f&#x3D;0 \<br>2 Q_{1}\left(b-\omega^{2}\right)\left(\dot{b}-\dot{b}^{<em>}\right)-2 q\left(b-\omega^{2}\right) e&#x3D;0 \<br>2 Q_{2}(a-2 \zeta \omega)\left(\dot{a}-\dot{a}^{</em>}\right)-2 q(a-2 \zeta \omega) \dot{e}&#x3D;0<br>\end{array}<br>$$<br>即:<br>$$<br>\begin{array}{l}<br>\dot{f}-\dot{f}^{<em>}&#x3D;-\frac{1}{Q_{0}} q \<br>\dot{b}-\dot{b}^{</em>}&#x3D;\frac{1}{Q_{1}} q e \<br>\dot{a}-\dot{a}^{<em>}&#x3D;\frac{1}{Q_{2}} q \dot{e}<br>\end{array}<br>$$<br>由式(4-32)可知, 式(4-30)可变化为:<br>$$<br>\dot{V}&#x3D;-E^{T} Q E+2 f^{</em>} q-2 b^{<em>} q e-2 a^{</em>} q \dot{e}<br>$$<br>为保证 $\dot{V}&lt;0$ , 对  $f^{<em>}, a^{</em>}  和  b^{<em>}$  作如下设定:<br>$$<br>\begin{array}{l}<br>f^{</em>}&#x3D;-Q_{0}^{<em>} q \<br>b^{</em>}&#x3D;Q_{1}^{<em>} q e \<br>a^{</em>}&#x3D;Q_{2}^{<em>} q \dot{e}<br>\end{array}<br>$$<br>其中,  $Q_{0}^{</em>}, Q_{1}^{<em>}$  和  $Q_{2}^{</em>}$  为非负常数。根据式(4-34), 式(4-33)可改写为<br>$$<br>\dot{V}&#x3D;-E^{T} Q E-2 Q_{0}^{<em>} q^{2}-2 Q_{1}^{</em>}(q e)^{2}-2 Q_{2}^{<em>}(q \dot{e})^{2}<br>$$<br>由此可知  $\dot{V}&lt;0$ , 即  $\dot{V}$  负定, 根据 Lyapunov 稳定理论可知, 该系统是稳定的。 由式(4-32)和式(4-34)可知, 系统稳定时, 自适应控制率中的参数  $f, a$  和  $b$  应分别取为:<br>$$<br>\begin{array}{l}<br>\dot{f}&#x3D;-\frac{1}{Q_{0}} q-Q_{0}^{</em>} \frac{d}{d t}[q] \<br>\dot{b}&#x3D;\frac{1}{Q_{1}} q e+Q_{1}^{<em>} \frac{d}{d t}[q e] \<br>\dot{a}&#x3D;\frac{1}{Q_{2}} q \dot{e}+Q_{2}^{</em>} \frac{d}{d t}[q \dot{e}]<br>\end{array}<br>$$<br>对上式积分, 可得:<br>$$<br>\begin{array}{l}<br>f(t)&#x3D;f(0)-\frac{1}{Q_{0}} \int_{0}^{t} q(t) d t-Q_{0}^{<em>} q(t) \<br>b(t)&#x3D;b(0)+\frac{1}{Q_{1}} \int_{0}^{t} q(t) e(t) d t+Q_{1}^{</em>} q(t) e(t) \<br>a(t)&#x3D;a(0)+\frac{1}{Q_{2}} \int_{0}^{t} q(t) \dot{e}(t) d t+Q_{2}^{<em>} q(t) \dot{e}(t)<br>\end{array}<br>$$<br>其中,  $q(t)&#x3D;p_{2} e(t)+p_{3} \dot{e}(t)$  。<br>由式(4-23)和式(4-24)可知, 为保证系统是 Lyapunov意义下稳定的, 可将式(4-21) 中的参数  $\left[g(t), k_{p}(t), k_{a}(t)\right]$  进行如下设计:<br>$$<br>\begin{array}{l}<br>g(t)&#x3D;g(0)+\alpha_{1} \int_{0}^{t} q(t) d t+\alpha_{2} q(t) \<br>k_{p}(t)&#x3D;k_{p}(0)+\beta_{1} \int_{0}^{t} q(t) e(t) d t+\beta_{2} q(t) e(t) \<br>k_{d}(t)&#x3D;k_{d}(0)+\gamma_{1} \int_{0}^{t} q(t) \dot{e}(t) d t+\gamma_{2} q(t) \dot{e}(t) \<br>q(t)&#x3D;\lambda_{\rho} e(t)+\lambda_{d} \dot{e}(t)<br>\end{array}<br>$$<br>其中,  $\left(\lambda_{p}, \lambda_{d}\right)$  分别为正的位置和速度加权因子,  $\left(\alpha_{1}, \beta_{1}, \gamma_{1}\right)$  为正的积分自适应增益,  $\left(\alpha_{2}, \beta_{2}, \gamma_{2}\right)$  为非负的比例自适应增益,  $\left[g(0), k_{p}(0), k_{d}(0)\right]$  为各参数的初始值。 结合式(4-38), 对式(4-21)进行适当改变, 可写成:<br>$$<br>x_{r}(t)&#x3D;x_{r}(0)+k_{p}^{</em>}(t) e(t)+k_{i}^{<em>} \int_{0}^{t} e(t) d t+k_{d}^{</em>} \dot{e}(t)<br>$$<br>其中,  $k_{p}^{<em>}&#x3D;\alpha_{1} \lambda_{d}+\alpha_{2} \lambda_{p}+k_{p}(t), k_{i}^{</em>}&#x3D;\alpha_{1} \lambda_{p}, k_{d}^{*}&#x3D;\alpha_{2} \lambda_{d}+k_{d}(t)$  且  $x_{r}(0)&#x3D;g(0)$  。<br>通过以上分析可知, 参考位置  $x_{r}(t)$  实际上是由关于力跟踪误差  $e(t)$  的一种 PID 控制器生成的。该控制器中, 积分项 I 的系数为常量增益, 比例微分项 PD 系数为s自适应增。<br>以上所述即为本文采用的自适应阻抗控制策略, 值得注意的是, 本控制器中 不含有环境位置  $x_{e}$  和环境刚度  $k_{e}$ , 并可以基于力跟踪误差性能指标  $e, \dot{e}$  对控制系统 进行在线调节。因此, 本文所设计的自适应阻抗控制方法可以快速适应大幅度的环境位置或环境刚度突变。</p><p>3.力&#x2F;位混合控制 Hybrid position&#x2F;force control</p><h2 id="最优控制理论在倒立摆系统中的应用"><a href="#最优控制理论在倒立摆系统中的应用" class="headerlink" title="最优控制理论在倒立摆系统中的应用"></a>最优控制理论在倒立摆系统中的应用</h2><p>状态反馈矩阵的求解过程<br>寻找控制率u，使得J最小<br>$$\begin{aligned}<br>J&#x3D;\psi\left[x\left(t_{f}\right)\right] &amp; +\int_{t_{0}}^{t_{f}} L[x(t), u(t), t] d t \<br>\text { subject to } \dot{x} &amp; &#x3D;f(x(t), u(t), t) \<br>x\left(t_{o}\right) &amp; &#x3D;x_{o}<br>\end{aligned}$$<br>用成本向量  $\lambda$ , 引入新的代价函数:<br>$$<br>\bar{J}&#x3D;\psi\left[x\left(t_{f}\right)\right]+\int_{t_{0}}^{t_{f}}\left[L+\lambda^{T}(f-\dot{x})\right] d t<br>$$<br>显然, 成本向量  $\lambda$  可以任意取值, 因为:<br>$$<br>f-\dot{x}&#x3D;0<br>$$<br>沿着最优路径, $J$和  $\bar{J}$  的变化应该消失 (等于 0 )<br>$$<br>\delta \bar{J}&#x3D;\psi_{x} \delta x\left(t_{f}\right)+\int_{t_{o}}^{t_{f}}\left[L_{x} \delta x+L_{u} \delta u+\lambda^{T} f_{x} \delta x+\lambda^{T} f_{u} \delta u-\lambda^{T} \delta \dot{x}\right] d t,<br>$$<br>其中, 下标代表偏导数。<br>用成本向量  $\lambda$ , 引入新的代价函数:<br>$$<br>\bar{J}&#x3D;\psi\left[x\left(t_{f}\right)\right]+\int_{t_{0}}^{t_{f}}\left[L+\lambda^{T}(f-\dot{x})\right] d t<br>$$<br>显然, 成本向量  $\lambda$  可以任意取值, 因为:<br>$$<br>f-\dot{x}&#x3D;0<br>$$<br>沿着最优路径, $J$和  $\bar{J}$  的变化应该消失 (等于 0 )<br>$$<br>\delta \bar{J}&#x3D;\psi_{x} \delta x\left(t_{f}\right)+\int_{t_{o}}^{t_{f}}\left[L_{x} \delta x+L_{u} \delta u+\lambda^{T} f_{x} \delta x+\lambda^{T} f_{u} \delta u-\lambda^{T} \delta \dot{x}\right] d t,<br>$$<br>其中, 下标代表偏导数。利用分部积分法:<br>$$<br>-\int_{t_{o}}^{t_{f}} \lambda^{T} \delta \dot{x} d t&#x3D;-\lambda^{T}\left(t_{f}\right) \delta x\left(t_{f}\right)+\lambda^{T}\left(t_{o}\right) \delta x\left(t_{o}\right)+\int_{t_{o}}^{t_{f}} \dot{\lambda}^{T} \delta x d t,<br>$$<br>将分部积分法的表达式, 带入  $\bar{J}$  的变化量表达式中:<br>$$<br>\begin{aligned}<br>\delta \bar{J}&#x3D; &amp; \psi_{x}\left(x\left(t_{f}\right)\right) \delta x\left(t_{f}\right)+\int_{t_{o}}^{t_{f}}\left(L_{u}+\lambda^{T} f_{u}\right) \delta u d t+ \<br>&amp; \int_{t_{o}}^{t_{f}}\left(L_{x}+\lambda^{T} f_{x}+\dot{\lambda}^{T}\right) \delta x d t-\lambda^{T}\left(t_{f}\right) \delta x\left(t_{f}\right)+\lambda^{T}\left(t_{o}\right) \delta x\left(t_{o}\right) .<br>\end{aligned}<br>$$<br> $\lambda^{T}\left(t_{o}\right) \delta x\left(t_{o}\right)$  等于0, 因为初始状态是常数。<br> $$<br>\begin{aligned}<br>\delta \bar{J}&#x3D; &amp; \psi_{x}\left(x\left(t_{f}\right)\right) \delta x\left(t_{f}\right)+\int_{t_{o}}^{t_{f}}\left(L_{u}+\lambda^{T} f_{u}\right) \delta u d t+ \<br>&amp; \int_{t_{o}}^{t_{f}}\left(L_{x}+\lambda^{T} f_{x}+\dot{\lambda}^{T}\right) \delta x d t-\lambda^{T}\left(t_{f}\right) \delta x\left(t_{f}\right)<br>\end{aligned}<br>$$<br>为了保证增量为 0 , 增量表达式中的三个组成部分, 就应该分别<br>等于0:<br>$$<br>\begin{aligned}<br>L_{u}+\lambda^{T} f_{u} &amp; &#x3D;0 \<br>L_{x}+\lambda^{T} f_{x}+\dot{\lambda}^{T} &amp; &#x3D;0 \<br>\psi_{x}\left(x\left(t_{f}\right)\right)-\lambda^{T}\left(t_{f}\right) &amp; &#x3D;0 .<br>\end{aligned}<br>$$<br>第二项和第三项, 可以重新写为下式:<br>$$<br>\begin{aligned}<br>\dot{\lambda}^{T} &amp; &#x3D;-L_{x}-\lambda^{T} f_{x} \<br>\lambda_{T}\left(t_{f}\right) &amp; &#x3D;\psi_{x}\left(x\left(t_{f}\right)\right) .<br>\end{aligned}<br>$$<br>针对线性二次型调节器 (LQR)：<br>$$<br>L&#x3D;\frac{1}{2} x^{T} Q x+\frac{1}{2} u^{T} R u,<br>$$<br>对比最一般的表达式:<br>$$<br>\delta \bar{J}&#x3D;\psi_{x} \delta x\left(t_{f}\right)+\int_{t_{o}}^{t_{f}}\left[L_{x} \delta x+L_{u} \delta u+\lambda^{T} f_{x} \delta x+\lambda^{T} f_{u} \delta u-\lambda^{T} \delta \dot{x}\right] d t,<br>$$<br>可以得到如下结果:<br>$$<br>\begin{aligned}<br>L_{x} &amp; &#x3D;x^{T} Q \<br>L_{u} &amp; &#x3D;u^{T} R \<br>f_{x} &amp; &#x3D;A \<br>f_{u} &amp; &#x3D;B,<br>\end{aligned}<br>$$<br>对比最优路径上, 增量为 0 的结论:<br>$$<br>\begin{array}{l}<br>\begin{array}{ll}<br>L_{u}+\lambda^{T} f_{u}&#x3D;0 &amp; L_{x}&#x3D;x^{T} Q \<br>L_{u}&#x3D;u^{T} R<br>\end{array} \<br>L_{x}+\lambda^{T} f_{x}+\dot{\lambda}^{T}&#x3D;0 \quad f_{x}&#x3D;A \<br>\psi_{x}\left(x\left(t_{f}\right)\right)-\lambda^{T}\left(t_{f}\right)&#x3D;0 . \quad f_{u}&#x3D;B, \<br>\dot{x}&#x3D;A x+B u \<br>\text { 可以得到如下结果: } \<br>x\left(t_{o}\right)&#x3D;x_{o} \<br>\dot{\lambda}&#x3D;-Q x-A^{T} \lambda \<br>\lambda\left(t_{f}\right)&#x3D;0 \<br>R u+B^{T} \lambda&#x3D;0 . \<br>\end{array}<br>$$<br>针对线性系统, 假设成本向量  $\lambda$  和 $x$  之间, 满足:  $\quad \lambda&#x3D;P x$ .<br>对比最优路径上, 增量为 0 的结论:<br>$$<br>\begin{array}{l}<br>\begin{array}{ll}<br>L_{u}+\lambda^{T} f_{u}&#x3D;0 &amp; L_{x}&#x3D;x^{T} Q \<br>L_{u}&#x3D;u^{T} R<br>\end{array} \<br>L_{x}+\lambda^{T} f_{x}+\dot{\lambda}^{T}&#x3D;0 \quad f_{x}&#x3D;A \<br>\psi_{x}\left(x\left(t_{f}\right)\right)-\lambda^{T}\left(t_{f}\right)&#x3D;0 . \quad f_{u}&#x3D;B, \<br>\dot{x}&#x3D;A x+B u \<br>\text { 可以得到如下结果: } \<br>x\left(t_{o}\right)&#x3D;x_{o} \<br>\dot{\lambda}&#x3D;-Q x-A^{T} \lambda \<br>\lambda\left(t_{f}\right)&#x3D;0 \<br>R u+B^{T} \lambda&#x3D;0 . \<br>\end{array}<br>$$<br>针对线性系统, 假设成本向量  $\lambda$  和  $x$  之间, 满足:  $\quad \lambda&#x3D;P x$ .<br>系统的控制量等于:  $\quad R u+B^{T} \lambda&#x3D;0 . \quad \lambda&#x3D;P x$.<br>$$<br>u&#x3D;-R^{-1} B^{T} \lambda&#x3D;-R^{-1} B^{T} P x<br>$$<br>对于状态反馈控制器, 而言:<br>$$<br>u&#x3D;-K x<br>$$<br>对比上述两式, 可得:<br>$$<br>K&#x3D;R^{-1} B^{T} P<br>$$</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>初识obsidian——写markdown的好伙伴</title>
    <link href="/2022/11/23/obsidian-1/"/>
    <url>/2022/11/23/obsidian-1/</url>
    
    <content type="html"><![CDATA[<p>obsidian写markdown吊打vscode！我说的！(</p><span id="more"></span><p>其实也不尽然，很多博客相关的设置还是vscode好用（<br>但是obsidian有自己的长处。<br>obsidian是一款基于markdown语法的笔记软件，但是它也可以单纯的用作一款markdown编译器使用。 </p><p>优点其一：支持多端的编辑，ios，Android，mac，windows等都有客户端，随时随地都可以掏出设备进行编辑，但是官方多设备共享仓库需付费，可以用git等工具进行多端备份。</p><p>优点其二：支持预览基于mathjax的数学公式，工科生福音<br><del>（呃呃但是平常根本不想慢悠悠的写公式）</del><br>Markdown自己不具有渲染数学公式的能力，而公式在Obsidian中却可以显示成我们熟悉的样子，因为Obsidian自己内置了Mathjax显示引擎来渲染数学公式 （实测vscode有插件也可以做到）<br>这里放一个隔壁的beyes公式，在obsidian里面可以直接预览，非常方便  </p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">$$<br>P<span class="hljs-comment">(\omega_i|x)</span> = &#123;p<span class="hljs-comment">(x,\omega_i)</span> \over p<span class="hljs-comment">(x)</span>&#125; = &#123;p<span class="hljs-comment">(x|\omega_i)</span>P<span class="hljs-comment">(\omega_i)</span> \over p<span class="hljs-comment">(x)</span>&#125;, i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span><br>$$<br></code></pre></td></tr></table></figure><p>$$<br>P(\omega_i|x) &#x3D; {p(x,\omega_i) \over p(x)} &#x3D; {p(x|\omega_i)P(\omega_i) \over p(x)}, i&#x3D;1,2<br>$$</p><p>顺便备份下写的很好的两篇博客<br><a href="https://www.cnblogs.com/linxd/p/4955530.html">Mathjax与LaTex公式简介 - 林大勇 - 博客园 (cnblogs.com)</a><br><a href="https://blog.csdn.net/dabokele/article/details/79577072">Mathjax公式教程_dabokele的博客-CSDN博客_mathjax 公式</a><br>还有两个工具网站<br><a href="https://www.latexlive.com/">在线LaTeX公式编辑器-编辑器 (latexlive.com)</a><br><a href="https://latex.codecogs.com/legacy/eqneditor/editor.php?tdsourcetag=s_pctim_aiomsg">Online LaTeX Equation Editor - create, integrate and download (codecogs.com)</a>  </p><p>优点其三：超链接粘贴非常人性化，直接ctrlc+ctrlv就帮你规矩的写好格式了</p><p>优点其四：支持插件和思维导图，👴还没用，所以这里先不谈，留着后面来补全</p><p>现在的想法是先用obsidian写自己的日常学习积累，然后将一些成体系的东西用vscode修改一下丢到这里来。<br>大概就酱？<br>最后带个优秀的obsidianQA网站<br><a href="https://jackiexiao.github.io/obsidian-chinese-help/">Obsidian群分享 (jackiexiao.github.io)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>做着玩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拿到一个python项目怎么迅速上手跑通之速通配环境</title>
    <link href="/2022/10/29/pythonyizhi/"/>
    <url>/2022/10/29/pythonyizhi/</url>
    
    <content type="html"><![CDATA[<p>关键词：python pipreqs 虚拟环境</p><span id="more"></span><blockquote><p>*<strong>套盾</strong>：本人非计算机科班出身，如有问题，请多指正。</p></blockquote><blockquote><p>*<strong>NOTICE</strong>：<br>碎碎念，可以跳过<br>事情的起因是这样的，学长给了我一个做好的毕设：六轴机械臂，叫我自己先跑通。奈何给的文件中并未有详细的上手流程，我只能自己揣摩着完成。<br>项目的主要逻辑是这样的，机械臂由下位机工控板硬石-F4pro控制，并与上位机（电脑或手机）进行数据传输。<br>在完成了工控板的程序下载后，我开始琢磨上位机，上位机是一个python项目，且并没有封装成exe文件，于是我必须建立起相关的环境才能打开上位机。</p></blockquote><p>首先准备好anaconda作为环境管理工具，Pycharm作为编译器。</p><p>拿到一个python项目，首先需要确定它的主文件和支持文件，主文件一般是main.py。但是这个项目中有很多包需要安装，一个一个的安装不免繁琐。</p><p>于是这里就要请出我们的好帮手：<strong>pipreqs</strong></p><p>它可以自动帮我们寻找文件中调用的包，并合并成requirements.txt文件，并支持方便的一次性多个包环境配置。</p><p>首先先打开anaconda，新建一个环境，如six-axis。建立后打开该环境的terminal，输入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pipreqs  <span class="hljs-comment"># 安装pipreqs</span><br></code></pre></td></tr></table></figure><p>接着cd到项目文件夹，输入</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">pipreqs <span class="hljs-string">./</span>                                    <span class="hljs-comment">##Linux: </span><br>pipreqs <span class="hljs-string">./</span> <span class="hljs-params">--encoding=utf-8</span>       <span class="hljs-comment">##Windows: </span><br></code></pre></td></tr></table></figure><p>如果不出问题，你就能在项目文件夹里看到新建的requirements.txt文件。打开可以看到一系列的包和对应的版本号。</p><p>最后使用</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip3 <span class="hljs-keyword">install</span> -r requirements.txt<br></code></pre></td></tr></table></figure><p>就可以单命令完成多个包安装了。但是这个方法有个小问题，就是有些较为小众的包他可能没法检测，如我这个项目中的roboticstoolbox，我后续手动安装的，但是好在只有这个包没有检测到。</p><p>然后就是快乐的开跑了</p><p>打开pycharm，File&gt;-&gt;open文件夹打开项目。打开main.py，右键调出Modify Run Configuration，选中刚刚建立的环境，右键直接<strong>RUN</strong>！</p><p>一个注意点是全程的Terminal都是Anaconda打开的对应环境的Terminal，不要直接使用编译器内部的Terminal，会出现奇怪的报错。</p><p>基本就酱，结束！</p><blockquote><p>参考文献：<br>吸爱思DN  <a href="https://huifeng.blog.csdn.net/article/details/104176310?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-104176310-blog-113347780.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-104176310-blog-113347780.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=3">https://huifeng.blog.csdn.net/article/details/104176310?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-104176310-blog-113347780.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-104176310-blog-113347780.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=3</a><br>逼乎  <a href="https://zhuanlan.zhihu.com/p/345671388">https://zhuanlan.zhihu.com/p/345671388</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>技术碎片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>novelai：全新的纸片人老婆可能性！</title>
    <link href="/2022/10/12/novelaitest/"/>
    <url>/2022/10/12/novelaitest/</url>
    
    <content type="html"><![CDATA[<p>近日看到AI绘图上热搜了。</p><span id="more"></span><p>我就去了解了一下，嚯，好家伙，这不diffusion model吗，想当年我中学时期还玩过它一个著名的web部署模型，记得好像叫100-anime-waifu，包括我现在的B站头像都是它生成的（笑）</p><p><img src="/img/bhead.png" alt="B站头像捏"></p><p>原来的模型生成经常会出现一些不可名状的扭曲肉块，而且很多二刺螈美少女的脸、鼻子、眼睛、嘴巴都牛头不对马嘴，比如一个正向面对你的脸却长了一对斜视的眼睛，十分鬼畜。还有例如画风不统一和人物边界露出的情况发生。在这种情况下，生成的图片直接能用的情况非常少，需要大量的人力去筛选。</p><p>新模型试了一下，调试模型的过程只能说跌宕起伏，最后基于我自己的经历，在不基于现有图片生成时，新模型的水平大大提高了，尤其是对脸部和整体的把控，但是以图片为基础的生成下限还是很低，略有问题，我拿实验室队徽连续跑了N次都没有跑出一个美少女，但是校徽就跑出了不错的结果。（可能是队徽太过简约？）语义分割也有些问题，有些人像图片塞进去并没有得到对应位置的人像，更像是按原图色块进行的绘制。</p><p>新模型我觉得最主要的提升可能主要还是大量训练集素材的积累，听说novelai模型基于一个绘画网站的训练而来，大量素材的积累对这样一个模型肯定有显著的提升。</p><p>对于技术的争议我无意评价，此处不再赘述。</p><p>没啥说的，就附点训练图片吧。</p><hr><p>校徽系列<br><img src="/img/xiaohui.jpg" alt="校徽"><br><img src="/img/xiaohui1.png" alt="有点抽象"><br><img src="/img/xiaohui2.png" alt="最喜欢的一张"><br><img src="/img/xiaohui3.png" alt="加了大量集成咒文的一张"></p><blockquote><p>感谢B站用户 @秋葉aaaki 的集成炼丹炉  <a href="https://www.bilibili.com/video/BV1EV4y1L7dX/?share_source=copy_web&vd_source=b83e6476fa9783512b3ec91a34e02b96">丹炉来源</a><br>还有知乎用户 @然诺 的咒文详解  <a href="https://www.zhihu.com/question/558019952/answer/2710009035?utm_campaign=&utm_medium=social&utm_oi=752833622943219712&utm_psn=1563165958105165824&utm_source=qq">炼丹扩展阅读</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>做着玩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS学习（2）ROS通讯机制</title>
    <link href="/2022/10/08/ROStutorials2/"/>
    <url>/2022/10/08/ROStutorials2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于<br><a href="http://www.autolabor.com.cn/book/ROSTutorials/">http://www.autolabor.com.cn/book/ROSTutorials/</a><br>和配套视频<br><a href="https://www.bilibili.com/video/BV1Ci4y1L7ZZ/">https://www.bilibili.com/video/BV1Ci4y1L7ZZ/</a><br>教程进行学习，本文仅作个人学习时的补充学习记录。<br>如果您是想要从零开始学习ROS,请移步上述网址。<br>本文可作为第二章补充阅读。</p></blockquote><span id="more"></span><h1 id="内容大纲（摘自上述教程）"><a href="#内容大纲（摘自上述教程）" class="headerlink" title="内容大纲（摘自上述教程）"></a>内容大纲（摘自上述教程）</h1><h2 id="话题通信"><a href="#话题通信" class="headerlink" title="话题通信"></a>话题通信</h2><p>话题通信是ROS中使用频率最高的一种通信模式，话题通信是基于发布订阅模式的，也即:一个节点发布消息，另一个节点订阅该消息。</p><p>ROS Master 负责保管 Talker 和 Listener 注册的信息，并匹配话题相同的 Talker 与 Listener，帮助 Talker 与 Listener 建立连接，连接建立后，Talker 可以发布消息，且发布的消息会被 Listener 订阅。</p><p>话题通信适用于不断更新的数据传输相关的应用场景。</p><h2 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h2><p>ROS Master 负责保管 Server 和 Client 注册的信息，并匹配话题相同的 Server 与 Client ，帮助 Server 与 Client 建立连接，连接建立后，Client 发送请求信息，Server 返回响应信息。</p><h2 id="参数服务器"><a href="#参数服务器" class="headerlink" title="参数服务器"></a>参数服务器</h2><p>ROS Master 作为一个公共容器保存参数，Talker 可以向容器中设置参数，Listener 可以获取参数。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1>]]></content>
    
    
    
    <tags>
      
      <tag>ROS学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS学习（1）ROS概述与环境搭建笔记</title>
    <link href="/2022/10/07/ROStutorials1/"/>
    <url>/2022/10/07/ROStutorials1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于<br><a href="http://www.autolabor.com.cn/book/ROSTutorials/">http://www.autolabor.com.cn/book/ROSTutorials/</a><br>和配套视频<br><a href="https://www.bilibili.com/video/BV1Ci4y1L7ZZ/">https://www.bilibili.com/video/BV1Ci4y1L7ZZ/</a><br>教程进行学习，本文仅作个人学习时的补充学习记录。<br>如果您是想要从零开始学习ROS,请移步上述网址。<br>本文可作为第一章补充阅读。</p></blockquote><span id="more"></span><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h2><p>CMake是一个跨平台的编译(Build)工具,可以用简单的语句来描述所有平台的编译过程。</p><p>CMake能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。</p><p>CMake 不仅可以编译源代码、制作程序库、产生适配器（wrapper）、还可以用任意的顺序建构执行档。CMake 支持 in-place 建构（二进档和源代码在同一个目录树中）和 out-of-place 建构（二进档在别的目录里），因此可以很容易从同一个源代码目录树中建构出多个二进档。CMake 也支持静态与动态程式库的建构。<br><a href="https://blog.csdn.net/weixin_45525272/article/details/122053959">原文及衍生学习</a></p><h2 id="BASH"><a href="#BASH" class="headerlink" title="BASH"></a>BASH</h2><p>Bash，Unix shell的一种，在1987年由布莱恩·福克斯为了GNU计划而编写。1989年发布第一个正式版本，原先是计划用在GNU操作系统上，但能运行于大多数类Unix系统的操作系统之上，包括Linux与Mac OS X v10.4都将它作为默认shell。</p><p>Bash是Bourne shell的后继兼容版本与开放源代码版本，它的名称来自Bourne shell（sh）的一个双关语（Bourne again &#x2F; born again）：Bourne-Again SHell。</p><p>Bash是一个命令处理器，通常运行于文本窗口中，并能执行用户直接输入的命令。Bash还能从文件中读取命令，这样的文件称为脚本。和其他Unix shell 一样，它支持文件名替换（通配符匹配）、管道、here文档、命令替换、变量，以及条件判断和循环遍历的结构控制语句。包括关键字、语法在内的基本特性全部是从sh借鉴过来的。其他特性，例如历史命令，是从csh和ksh借鉴而来。总的来说，Bash虽然是一个满足POSIX规范的shell，但有很多扩展。  </p><h3 id="Unix-shell"><a href="#Unix-shell" class="headerlink" title="Unix shell"></a>Unix shell</h3><p>Unix shell，通常被称作“命令行”，为Unix和类Unix操作系统提供了传统的用户界面。用户通过输入shell所执行的命令，引导计算机的操作。在微软Windows操作系统平台，类似程序是command.com，或者基于Windows NT内核操作系统的cmd.exe。</p><h2 id="src文件夹"><a href="#src文件夹" class="headerlink" title="src文件夹"></a>src文件夹</h2><p>src 在软件中都是指 source ，也就是 源代码 的意思。 在很多语言的工程里都一个src文件夹 用来存放源代码以区别开其它文件 （模板文件、Web文件等）。 </p><h2 id="xml文件"><a href="#xml文件" class="headerlink" title=".xml文件"></a>.xml文件</h2><p>XML (Extensible Markup Language) 是一种类似于 HTML 的标记语言，但是 XML 没有使用预定义的标记。 因此，您可以根据自己的设计需求定义专属于您的标记。 这是一种十分有用的可存储、可搜索和可共享的格式存储数据的方法。<br>.launch文件也属于.xml文件，ROS中用.launch文件来同时启动多个节点。<br><a href="https://www.runoob.com/xml/xml-intro.html">衍生学习</a></p><h2 id="json"><a href="#json" class="headerlink" title=".json"></a>.json</h2><p>JSON: JavaScript Object Notation(JavaScript 对象表示法)<br>JSON 是存储和交换文本信息的语法，类似 XML。<br>JSON 比 XML 更小、更快，更易解析，  JSON 易于人阅读和编写。<br>C、Python、C++、Java、PHP、Go等编程语言都支持 JSON。<br>在VScode里用作配置文件。<br><a href="http://c.biancheng.net/json/">衍生学习</a></p><h1 id="一点有意义的快捷键（in-VScode）"><a href="#一点有意义的快捷键（in-VScode）" class="headerlink" title="一点有意义的快捷键（in VScode）"></a>一点有意义的快捷键（in VScode）</h1><p><strong>ctrl+&#x2F;</strong><br>注释和反注释</p><p><strong>ctrl+shift+b</strong><br>编译</p><p><strong>ctrl+shift+p</strong><br>调出用于执行命令的输入框，这些命令来自VSCode自带已经插件扩展的命令。插件扩展命令可以查看以下示例，在package.json里注册命令，然后通过注册命令找到对应代码执行相应逻辑。</p><p><strong>ctrl+&#96;</strong><br>打开终端</p>]]></content>
    
    
    
    <tags>
      
      <tag>ROS学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>守望先锋，再见。</title>
    <link href="/2022/10/05/overwatch-return/"/>
    <url>/2022/10/05/overwatch-return/</url>
    
    <content type="html"><![CDATA[<p>如果要选一款我游戏中的白月光，毫无意外，就是守望先锋了。</p><span id="more"></span><p>和暴雪的不解之缘最开始出现在五年级的那个圣诞节晚上，我的父亲用他14英寸的老戴尔带着我打了我人生中第一把星际争霸。</p><p>虫族，速本爆狗一波流。</p><p>我难以想象在1998年就有人做出这样一款游戏性和世界观都无可挑剔的作品。靠着一本牛津英汉词典。我硬生生的打通了星际1的剧情模式。最后一幕CG放完的那个下午，我的人生目标就确立了：  </p><p>去暴雪，做出很COOL的游戏。</p><p>上了初中的我接触到了战网，续上了科普鲁星区的故事；开始了艾泽拉斯的冒险；结识了时空枢纽的英雄；交上了符文之地的朋友。耳闻暴雪在做一款名为TITAN的旷世MMORPG巨作，虽然其最后难产变成了一款射击游戏，但我也翘首以盼。</p><p>328元。那时候我没有银行卡没有支付宝，一张点卡30块，我买了11张。</p><p>拿着那一沓卡片走回家，我觉得我是这个世界上最幸福的小孩。</p><p>2016年，我14岁。近未来的故事背景，各具特色的角色设计，还有一堆待发掘的彩蛋和对英雄的致意。机械忍者，时空回溯，能变成重机枪的机器人，靠着音乐战斗的DJ，穿着合金重铠拿着喷射巨锤的圣骑士，掌握起死回生之力的战场女武神。每个中午，我都会骑上我的小单车，风驰电掣地飞回家中，用U盘里准备好的程序干开那台WINDOWS7的密码，徜徉在那个世界里。</p><p>但是，我长大了，它没有。</p><p>不知什么时候，暴雪死了。先是商业化赛事失败，然后是风暴英雄停更，然后是星际，然后是“你们没有手机吗？”，然后是原版没啥区别的魔兽Ⅲ重置和父马可亲的汉化······我都记不清先后了，我也从一个只玩暴雪游戏的暴白变成了恨不得暴雪早点死的暴黑。</p><p>你问守望？守望一直是那样，除了一点无足轻重的平衡性改动外，开发组就像死了一样销声匿迹。</p><p>都这样了，体面点吧。</p><p>我本来不想给暴雪这个机会了。</p><p>但我说不上来。</p><p>守望先锋关服了。</p><p>我的青春结束了。</p><p>或者说，它早就结束了，只是需要一个体面的葬礼。</p><p>至于守望二，我已经不是14岁了，暴雪也不是那个暴雪了。</p><p>但是我愿意给他这个机会。</p><p>这个世界需要英雄。</p>]]></content>
    
    
    
    <tags>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重走大一路：STM32的入门笔记(1)</title>
    <link href="/2022/10/04/STM32-1/"/>
    <url>/2022/10/04/STM32-1/</url>
    
    <content type="html"><![CDATA[<p>STM32作为现今最常用的机器人主控MPU非常重要，很有必要好好学习。第一章笔记，将给出它的概述。</p><span id="more"></span><p>我将解答部分我之前不太明白的部分问题和术语，希望对看这篇文章的你也有些帮助。</p><h1 id="1-初识STM32"><a href="#1-初识STM32" class="headerlink" title="1.初识STM32"></a>1.初识STM32</h1><blockquote><p>STM32系列是专为要求高性能、低成本、低功耗的嵌入式应用设计的ARM Cortex®-M0，M0+，M3, M4和M7内核 （ST’s product portfolio contains a comprehensive range of microcontrollers, from robust, low-cost 8-bit MCUs up to 32-bit ARM-based Cortex®-M0 and M0+, Cortex®-M3,Cortex®-M4 Flash microcontrollers with a great choice of peripherals. ST has also extended this range to include an ultra-low-power MCU platform)。<br>按内核架构分为不同产品：主流产品（STM32F0、STM32F1、STM32F3）、超低功耗产品（STM32L0、STM32L1、STM32L4、STM32L4+）、高性能产品（STM32F2、STM32F4、STM32F7、STM32H7<br>（来自百度百科）</p></blockquote><p>用人话讲，STM32是一款32位的单片机MCU(Micro Control Unit)，适用于许多开发环境。它就是整个机器人的大脑，负责主控。它通过控制引脚上的高低电平来控制外部执行器。<br>它的内核基于<strong>ARM® Cortex®-M</strong>（一种ARM公司的处理器架构设计）。<a href="https://blog.csdn.net/erinblog/article/details/78156032">衍生阅读</a></p><p>想使用STM32首先我们要会<a href="https://www.dotcpp.com/"><strong>C语言</strong></a>。还要有基本的<strong>模电数电知识</strong>。若有<strong>计算机组成原理</strong>的基础更好，但不会也不影响基本的使用。</p><h1 id="2-命名规则"><a href="#2-命名规则" class="headerlink" title="2.命名规则"></a>2.命名规则</h1><p><img src="/img/stmxiangjie.png"></p><h1 id="3-术语解释"><a href="#3-术语解释" class="headerlink" title="3.术语解释"></a>3.术语解释</h1><h2 id="开发板"><a href="#开发板" class="headerlink" title="开发板"></a>开发板</h2><p>开发板是一些企业或组织为了方便不懂硬件设计的群体设计的含主控芯片的电路板，上面有各种元器件和接口，方便这些群体直接通过开发板进行对主控的编程和对执行器的控制。</p><h2 id="上位机和下位机"><a href="#上位机和下位机" class="headerlink" title="上位机和下位机"></a>上位机和下位机</h2><blockquote><p>上位机是指可以直接发出操控命令的计算机，一般是PC&#x2F;host computer&#x2F;master computer&#x2F;upper computer,屏幕上显示各种信号变化（液压，水位，温度等）。下位机是直接控制设备获取设备状况的计算机，一般是PLC&#x2F;单片机single chip microcomputer&#x2F;slave computer&#x2F;lower computer之类的。上位机发出的命令首先给下位机，下位机再根据此命令解释成相应时序信号直接控制相应设备。下位机不时读取设备状态数据（一般为模拟量），转换成数字信号反馈给上位机。简言之如此，实际情况千差万别，但万变不离其宗：上下位机都需要编程，都有专门的开发系统。<br>在概念上，控制者和提供服务者是上位机，被控制者和被服务者是下位机，也可以理解为主机和从机的关系，但上位机和下位机是可以转换的。<br><a href="https://zhuanlan.zhihu.com/p/77587097#:~:text=%E4%B8%8A%E4%BD%8D%E6%9C%BA%E6%98%AF%E6%8C%87%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%8F%91%E5%87%BA%E6%93%8D%E6%8E%A7%E5%91%BD%E4%BB%A4%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%8C%E4%B8%80%E8%88%AC%E6%98%AFPC%2Fhost%20computer%2Fmaster%20computer%2Fupper%20computer%2C%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%90%84%E7%A7%8D%E4%BF%A1%E5%8F%B7%E5%8F%98%E5%8C%96%EF%BC%88%E6%B6%B2%E5%8E%8B%EF%BC%8C%E6%B0%B4%E4%BD%8D%EF%BC%8C%E6%B8%A9%E5%BA%A6%E7%AD%89%EF%BC%89%E3%80%82,%E4%B8%8B%E4%BD%8D%E6%9C%BA%E6%98%AF%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E8%AE%BE%E5%A4%87%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E7%8A%B6%E5%86%B5%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%8C%E4%B8%80%E8%88%AC%E6%98%AFPLC%2F%E5%8D%95%E7%89%87%E6%9C%BAsingle%20chip%20microcomputer%2Fslave%20computer%2Flower%20computer%E4%B9%8B%E7%B1%BB%E7%9A%84%E3%80%82">引用来源</a></p></blockquote><h2 id="HAL库，标准库和直接配置寄存器"><a href="#HAL库，标准库和直接配置寄存器" class="headerlink" title="HAL库，标准库和直接配置寄存器"></a>HAL库，标准库和直接配置寄存器</h2><p>STM32的开发商ST（意法半导体）官方有封装好的<a href="https://cloud.tencent.com/developer/article/1861948"><strong>HAL库</strong></a>（ST官方推荐的库），<strong>标准固件库</strong>（旧版本库，现已不再更新）可用于STM32的编程，同样你也可以使用<strong>寄存器编程</strong>（较繁琐）。现在大部分情况都使用HAL库。</p><blockquote><p>1、直接配置寄存器<br>不少先学了51的朋友可能会知道，会有一小部分人或是教程是通过汇编语言直接操作寄存器实现功能的，这种方法到了STM32就变得不太容易行得通了，因为STM32的寄存器数量是51单片机的十数倍，如此多的寄存器根本无法全部记忆，开发时需要经常的翻查芯片的数据手册，此时直接操作寄存器就变得非常的费力了。但还是会有很小一部分人，喜欢去直接操作寄存器，因为这样更接近原理，知其然也知其所以然。<br>2、标准库<br>上面也提到了，STM32有非常多的寄存器，而导致了开发困难，所以为此ST公司就为每款芯片都编写了一份库文件，也就是工程文件里stm32F1xx…之类的。在这些 .c .h文件中，包括一些常用量的宏定义，把一些外设也通过结构体变量封装起来，如GPIO口时钟等。所以我们只需要配置结构体变量成员就可以修改外设的配置寄存器，从而选择不同的功能。也是目前最多人使用的方式，也是学习STM32接触最多的一种开发方式，我也就不多阐述了。<br>3、HAL库<br>HAL库是ST公司目前主力推的开发方式，全称就是Hardware Abstraction Layer（抽象印象层）。库如其名，很抽象，一眼看上去不太容易知道他的作用是什么。<br>它的出现比标准库要晚，但其实和标准库一样，都是为了节省程序开发的时期，而且HAL库尤其的有效，如果说标准库把实现功能需要配置的寄存器集成了，那么HAL库的一些函数甚至可以做到某些特定功能的集成。也就是说，同样的功能，标准库可能要用几句话，HAL库只需用一句话就够了。<br>并且HAL库也很好的解决了程序移植的问题，不同型号的stm32芯片它的标准库是不一样的，例如在F4上开发的程序移植到F3上是不能通用的，而使用HAL库，只要使用的是相通的外设，程序基本可以完全复制粘贴，注意是相通外设，意思也就是不能无中生有，例如F7比F3要多几个定时器，不能明明没有这个定时器却非要配置，但其实这种情况不多，绝大多数都可以直接复制粘贴。是而且使用ST公司研发的STMcube软件，可以通过图形化的配置功能，直接生成整个使用HAL库的工程文件，可以说是方便至极，但是方便的同时也造成了它执行效率的低下，在各种论坛帖子真的是被吐槽的数不胜数。</p></blockquote><p><a href="https://cloud.tencent.com/developer/article/1861948">引用来源及扩展阅读</a></p><h2 id="8位，32位和64位"><a href="#8位，32位和64位" class="headerlink" title="8位，32位和64位"></a>8位，32位和64位</h2><p>32位和64位操作系统是指，CPU一次处理数据的能力是32位还是64位。  所谓32位，就是CPU一次只能处理32位，也就是4个字节的数据；而64位，CPU一次就能处理64位，即8个字节的数据。<br>51单片机大部分为8位，而STM32的位数为32位。</p><h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><blockquote><p>Jlink支持所有ARM芯片的仿真调试，而STlink仅仅支持ST公司的相关芯片。<br><a href="https://blog.csdn.net/ReCclay/article/details/79156325">引用来源及扩展阅读</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>audio | 航站楼第一次的audio</title>
    <link href="/2022/10/02/first_audio/"/>
    <url>/2022/10/02/first_audio/</url>
    
    <content type="html"><![CDATA[<p>做技术的人的自我修养应该是怎么样的？我觉得大家心里都有自己的答案。</p><span id="more"></span><p>以我之鄙见，最重要的一点应该是热爱技术，其次应该是持续而稳定的热情输出，最后则是一点灵感和机遇。</p>]]></content>
    
    
    
    <tags>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据课程相关资料汇总</title>
    <link href="/2022/03/02/Bigdata_resources/"/>
    <url>/2022/03/02/Bigdata_resources/</url>
    
    <content type="html"><![CDATA[<p>本文旨在记录HIT大数据智能控制课程相关资料  </p><span id="more"></span><p>授课老师王金宝</p><h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h2><h3 id="GFS-Google-File-System"><a href="#GFS-Google-File-System" class="headerlink" title="GFS(Google File System)"></a>GFS(Google File System)</h3><p><a href="https://www.bilibili.com/video/BV1fT411c7y6/?spm_id_from=333.337.search-card.all.click&vd_source=62552d67d8de63c74ce35658499bc372">解读Google分布式文件系统GFS（合集）_哔哩哔哩_bilibili</a><br><a href="https://blog.csdn.net/Yaoman753/article/details/123786807">(71条消息) 【分布式系统】GFS(Google File System )详解_gfs数据_猎猎风中的博客-CSDN博客</a></p><h3 id="Bigtable"><a href="#Bigtable" class="headerlink" title="Bigtable"></a>Bigtable</h3><p><a href="https://www.bilibili.com/video/BV1bj41137BY/?spm_id_from=333.337.search-card.all.click&vd_source=62552d67d8de63c74ce35658499bc372">【论文笔记】解读Google三驾马车之Bigtable（合集）_哔哩哔哩_bilibili</a></p><h3 id="Dynamo"><a href="#Dynamo" class="headerlink" title="Dynamo"></a>Dynamo</h3>]]></content>
    
    
    
    <tags>
      
      <tag>技术碎片</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
